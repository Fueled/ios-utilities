{"identifier":{"url":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras","interfaceLanguage":"swift"},"schemaVersion":{"minor":3,"major":0,"patch":0},"metadata":{"externalID":"ConcurrencyExtras","roleHeading":"Framework","title":"ConcurrencyExtras","modules":[{"name":"ConcurrencyExtras"}],"symbolKind":"module","role":"collection"},"abstract":[{"text":"Useful, testable Swift concurrency.","type":"text"}],"topicSections":[{"anchor":"Data-races","identifiers":["doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/LockIsolated","doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/AnyHashableSendable"],"title":"Data races"},{"anchor":"Serial-execution","identifiers":["doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/ReliablyTestingAsync"],"title":"Serial execution"},{"anchor":"Preconcurrency","identifiers":["doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/UncheckedSendable"],"title":"Preconcurrency"},{"generated":true,"anchor":"Articles","identifiers":["doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/ActorIsolatedDeprecations"],"title":"Articles"},{"generated":true,"anchor":"Variables","identifiers":["doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/uncheckedUseMainSerialExecutor"],"title":"Variables"},{"generated":true,"anchor":"Functions","identifiers":["doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/withMainSerialExecutor(operation:)-6s3c0","doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/withMainSerialExecutor(operation:)-7fqt1"],"title":"Functions"},{"generated":true,"anchor":"Extended-Modules","identifiers":["doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/Swift","doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/_Concurrency"],"title":"Extended Modules"}],"kind":"symbol","sections":[],"hierarchy":{"paths":[[]]},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/concurrencyextras"]}],"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","type":"heading","level":2,"text":"Overview"},{"inlineContent":[{"type":"text","text":"This library comes with a number of tools that make working with Swift concurrency easier and more"},{"type":"text","text":" "},{"type":"text","text":"testable."}],"type":"paragraph"},{"anchor":"LockIsolated","type":"heading","level":3,"text":"LockIsolated"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"LockIsolated"},{"type":"text","text":" type helps wrap other values in an isolated context. It wraps the value in a"},{"type":"text","text":" "},{"type":"text","text":"class with a lock, which allows you to read and write the value with a synchronous interface."}],"type":"paragraph"},{"anchor":"Streams","level":3,"type":"heading","text":"Streams"},{"inlineContent":[{"type":"text","text":"The library comes with numerous helper APIs spread across the two Swift stream types:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"There are helpers that erase any ","type":"text"},{"code":"AsyncSequence","type":"codeVoice"},{"type":"text","text":" conformance to either concrete stream type."},{"type":"text","text":" "},{"text":"This allows you to treat the stream type as a kind of “type erased” ","type":"text"},{"code":"AsyncSequence","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"For example, suppose you have a dependency client like this:","type":"text"}]},{"syntax":"swift","code":["struct ScreenshotsClient {","  var screenshots: () -> AsyncStream<Void>","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then you can construct a live implementation that “erases” the"},{"text":" ","type":"text"},{"type":"codeVoice","code":"NotificationCenter.Notifications"},{"text":" async sequence to a stream:","type":"text"}]},{"syntax":"swift","code":["extension ScreenshotsClient {","  static let live = Self(","    screenshots: {","      NotificationCenter.default","        .notifications(named: UIApplication.userDidTakeScreenshotNotification)","        .map { _ in }","        .eraseToStream()  \/\/ ⬅️","    }","  )","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Use "},{"code":"eraseToThrowingStream()","type":"codeVoice"},{"type":"text","text":" to propagate failures from throwing async sequences."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"There is an API for simultaneously constructing a stream and its backing continuation. This can"},{"type":"text","text":" "},{"type":"text","text":"be handy in tests when overriding a dependency endpoint that returns a stream:"}]},{"syntax":"swift","code":["let screenshots = AsyncStream<Void>.streamWithContinuation()","let model = FeatureModel(screenshots: screenshots.stream)","","XCTAssertEqual(model.screenshotCount, 0)","screenshots.continuation.yield()  \/\/ Simulate a screenshot being taken.","XCTAssertEqual(model.screenshotCount, 1)"],"type":"codeListing"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Static "},{"code":"AsyncStream.never","type":"codeVoice"},{"type":"text","text":" and "},{"code":"AsyncThrowingStream.never","type":"codeVoice"},{"text":" helpers are provided that represent","type":"text"},{"text":" ","type":"text"},{"text":"streams that live forever and never emit. They can be handy in tests that need to override a","type":"text"},{"text":" ","type":"text"},{"text":"dependency endpoint with a stream that should suspend and never emit for the duration test.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Static ","type":"text"},{"code":"AsyncStream.finished","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"AsyncThrowingStream.finished(throwing:)","type":"codeVoice"},{"text":" helpers are provided","type":"text"},{"text":" ","type":"text"},{"text":"that represents streams that complete immediately without emitting. They can be handy in tests","type":"text"},{"text":" ","type":"text"},{"text":"that need to override a dependency endpoint with a stream that completes\/fails immediately.","type":"text"}]}]}]},{"anchor":"Tasks","type":"heading","level":3,"text":"Tasks"},{"inlineContent":[{"text":"The library comes with a static function, ","type":"text"},{"code":"Task.never()","type":"codeVoice"},{"text":", that can asynchronously return a value of","type":"text"},{"text":" ","type":"text"},{"text":"any type, but does so by suspending forever. This can be useful for satisfying a dependency","type":"text"},{"text":" ","type":"text"},{"text":"requirement in a way that does not require you to actually return data from that endpoint.","type":"text"}],"type":"paragraph"},{"anchor":"UncheckedSendable","type":"heading","level":3,"text":"UncheckedSendable"},{"inlineContent":[{"type":"text","text":"A wrapper type that can make any type "},{"code":"Sendable","type":"codeVoice"},{"text":", but in an unsafe and unchecked way. This type","type":"text"},{"type":"text","text":" "},{"text":"should only be used as an alternative to ","type":"text"},{"code":"@preconcurrency import","type":"codeVoice"},{"text":", which turns off concurrency","type":"text"},{"type":"text","text":" "},{"text":"checks for everything in the library. Whereas ","type":"text"},{"type":"reference","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/UncheckedSendable","isActive":true},{"text":" allows you to turn off","type":"text"},{"text":" ","type":"text"},{"text":"concurrency warnings for just one single usage of a particular type.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"While ","type":"text"},{"identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0302-concurrent-value-and-concurrent-closures.md","type":"reference","isActive":true},{"type":"text","text":" mentions future work of "},{"identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0302-concurrent-value-and-concurrent-closures.md#adaptor-types-for-legacy-codebases","type":"reference","isActive":true},{"text":", including an ","type":"text"},{"code":"UnsafeTransfer","type":"codeVoice"},{"text":" type that serves the same","type":"text"},{"text":" ","type":"text"},{"text":"purpose, it has not landed in Swift.","type":"text"}],"type":"paragraph"},{"anchor":"Serial-execution","type":"heading","level":3,"text":"Serial execution"},{"inlineContent":[{"text":"Some asynchronous code is ","type":"text"},{"identifier":"https:\/\/forums.swift.org\/t\/reliably-testing-code-that-adopts-swift-concurrency\/57304","type":"reference","isActive":true},{"text":" to test in","type":"text"},{"text":" ","type":"text"},{"text":"Swift due to how suspension points are processed by the runtime. The library comes with a static","type":"text"},{"text":" ","type":"text"},{"text":"function, ","type":"text"},{"code":"withMainSerialExecutor(operation:)-79jpc","type":"codeVoice"},{"text":", that runs all tasks spawned in an operation","type":"text"},{"text":" ","type":"text"},{"text":"serially and deterministically. This function can be used to make asynchronous tests faster and less","type":"text"},{"text":" ","type":"text"},{"text":"flakey.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Note that running async tasks serially does not mean that multiple concurrent tasks are not able to","type":"text"},{"text":" ","type":"text"},{"text":"interleave. Suspension of async tasks still works just as you would expect, but all tasks are run on","type":"text"},{"text":" ","type":"text"},{"text":"the unique, main thread.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"For example, consider the following simple ","type":"text"},{"code":"ObservableObject","type":"codeVoice"},{"text":" implementation for a feature that","type":"text"},{"text":" ","type":"text"},{"text":"wants to count the number of times a screenshot is taken of the screen:","type":"text"}],"type":"paragraph"},{"code":["class FeatureModel: ObservableObject {","  @Published var count = 0","  @MainActor","  func onAppear() async {","    let screenshots = NotificationCenter.default.notifications(","      named: UIApplication.userDidTakeScreenshotNotification","    )","    for await _ in screenshots {","      self.count += 1","    }","  }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"This is quite a simple feature, but in the future it could start doing more complicated things,","type":"text"},{"text":" ","type":"text"},{"text":"such as performing a network request when it detects a screenshot being taken.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"So, it would be great if we could get some test coverage on this feature. To do this we can create","type":"text"},{"text":" ","type":"text"},{"text":"a model, and spin up a new task to invoke the ","type":"text"},{"code":"onAppear","type":"codeVoice"},{"text":" method:","type":"text"}],"type":"paragraph"},{"code":["func testBasics() async {","  let model = ViewModel()","  let task = Task { await model.onAppear() }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"Then we can use ","type":"text"},{"code":"Task.yield()","type":"codeVoice"},{"text":" to allow the subscription of the stream of notifications to start:","type":"text"}],"type":"paragraph"},{"code":["func testBasics() async {","  let model = ViewModel()","  let task = Task { await model.onAppear() }","","  \/\/ Give the task an opportunity to start executing its work.","  await Task.yield()","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"Then we can simulate the user taking a screenshot by posting a notification:","type":"text"}],"type":"paragraph"},{"code":["func testBasics() async {","  let model = ViewModel()","  let task = Task { await model.onAppear() }","","  \/\/ Give the task an opportunity to start executing its work.","  await Task.yield()","","  \/\/ Simulate a screen shot being taken.","  NotificationCenter.default.post(","    name: UIApplication.userDidTakeScreenshotNotification, object: nil","  )","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"And then finally we can yield again to process the new notification and assert that the count","type":"text"},{"text":" ","type":"text"},{"text":"incremented by 1:","type":"text"}],"type":"paragraph"},{"code":["func testBasics() async {","  let model = ViewModel()","  let task = Task { await model.onAppear() }","","  \/\/ Give the task an opportunity to start executing its work.","  await Task.yield()","","  \/\/ Simulate a screen shot being taken.","  NotificationCenter.default.post(","    name: UIApplication.userDidTakeScreenshotNotification, object: nil","  )","","  \/\/ Give the task an opportunity to update the view model.","  await Task.yield()","","  XCTAssertEqual(model.count, 1)","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"This seems like a perfectly reasonable test, and it does pass… sometimes. If you run it enough","type":"text"},{"text":" ","type":"text"},{"text":"times you will eventually get a failure (about 6% of the time). This is happening because sometimes","type":"text"},{"text":" ","type":"text"},{"text":"the single ","type":"text"},{"code":"Task.yield()","type":"codeVoice"},{"text":" is not enough for the subscription to the stream of notifications to","type":"text"},{"text":" ","type":"text"},{"text":"actually start. In that case we will post the notification before we have actually subscribed,","type":"text"},{"text":" ","type":"text"},{"text":"causing a test failure.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"If we wrap the entire test in ","type":"text"},{"code":"withMainSerialExecutor(operation:)-79jpc","type":"codeVoice"},{"text":", then it will pass","type":"text"},{"text":" ","type":"text"},{"text":"deterministically, 100% of the time:","type":"text"}],"type":"paragraph"},{"code":["func testBasics() async {","  await withMainSerialExecutor {","    …","  }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"This is because now all tasks are enqueued on the serial, main executor, and so when we ","type":"text"},{"code":"Task.yield","type":"codeVoice"},{"text":" ","type":"text"},{"text":"we can be sure that the ","type":"text"},{"code":"onAppear","type":"codeVoice"},{"text":" method will execute until it reaches a suspension point. This","type":"text"},{"text":" ","type":"text"},{"text":"guarantees that the subscription to the stream of notifications will start when we expect it to.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"You can also use ","type":"text"},{"identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/withMainSerialExecutor(operation:)-7fqt1","type":"reference","isActive":true},{"text":" to wrap an entire test case by","type":"text"},{"text":" ","type":"text"},{"text":"overriding the ","type":"text"},{"code":"invokeTest","type":"codeVoice"},{"text":" method:","type":"text"}],"type":"paragraph"},{"code":["final class FeatureModelTests: XCTestCase {","  override func invokeTest() {","    withMainSerialExecutor {","      super.invokeTest()","    }","  }","  …","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"Now the entire ","type":"text"},{"code":"FeatureModelTests","type":"codeVoice"},{"text":" test case will be run on the main, serial executor.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Note that by using ","type":"text"},{"code":"withMainSerialExecutor(operation:)-79jpc","type":"codeVoice"},{"text":" you are technically making your","type":"text"},{"text":" ","type":"text"},{"text":"tests behave in a manner that is different from how they would run in production. However, many","type":"text"},{"text":" ","type":"text"},{"text":"tests written on a day-to-day basis due not invoke the full-blown vagaries of concurrency. Instead","type":"text"},{"text":" ","type":"text"},{"text":"the tests want to assert that some user action happens, an async unit of work is executed, and","type":"text"},{"text":" ","type":"text"},{"text":"that causes some state to change. Such tests should be written in a way that is 100% deterministic.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"If your code has truly complex asynchronous and concurrent operations, then it may be handy to write","type":"text"},{"text":" ","type":"text"},{"text":"two sets of tests: one set that targets the main executor (using","type":"text"},{"text":" ","type":"text"},{"code":"withMainSerialExecutor(operation:)-79jpc","type":"codeVoice"},{"type":"text","text":") so that you can deterministically assert how the core"},{"type":"text","text":" "},{"type":"text","text":"system behaves, and then another set that targets the default, global executor that will probably"},{"type":"text","text":" "},{"text":"need to make weaker assertions due to non-determinism, but can still assert on some things.","type":"text"}],"type":"paragraph"}]}],"references":{"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/Swift":{"url":"\/documentation\/concurrencyextras\/swift","kind":"symbol","role":"collection","type":"topic","abstract":[],"identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/Swift","title":"Swift"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/ActorIsolatedDeprecations":{"type":"topic","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/ActorIsolatedDeprecations","url":"\/documentation\/concurrencyextras\/actorisolateddeprecations","abstract":[{"type":"text","text":"Review unsupported reducer APIs and their replacements."}],"title":"Deprecations","kind":"article","role":"collectionGroup"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/_Concurrency":{"type":"topic","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/_Concurrency","url":"\/documentation\/concurrencyextras\/_concurrency","abstract":[],"kind":"symbol","title":"_Concurrency","role":"collection"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/UncheckedSendable":{"identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/UncheckedSendable","type":"topic","title":"UncheckedSendable","abstract":[{"type":"text","text":"A generic wrapper for turning any non-"},{"code":"Sendable","type":"codeVoice"},{"type":"text","text":" type into a "},{"code":"Sendable","type":"codeVoice"},{"type":"text","text":" one, in an unchecked"},{"type":"text","text":" "},{"type":"text","text":"manner."}],"kind":"symbol","role":"symbol","url":"\/documentation\/concurrencyextras\/uncheckedsendable","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"UncheckedSendable","kind":"identifier"}],"navigatorTitle":[{"text":"UncheckedSendable","kind":"identifier"}],"deprecated":true},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/withMainSerialExecutor(operation:)-6s3c0":{"kind":"symbol","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"withMainSerialExecutor"},{"kind":"text","text":"("},{"kind":"externalParam","text":"operation"},{"kind":"text","text":": () "},{"kind":"keyword","text":"async"},{"kind":"text","text":" "},{"kind":"keyword","text":"throws"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","preciseIdentifier":"s:s4Voida","text":"Void"},{"kind":"text","text":") "},{"kind":"keyword","text":"async"},{"kind":"text","text":" "},{"kind":"keyword","text":"rethrows"}],"title":"withMainSerialExecutor(operation:)","role":"symbol","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/withMainSerialExecutor(operation:)-6s3c0","type":"topic","abstract":[{"type":"text","text":"Perform an operation on the main serial executor."}],"url":"\/documentation\/concurrencyextras\/withmainserialexecutor(operation:)-6s3c0"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/withMainSerialExecutor(operation:)-7fqt1":{"identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/withMainSerialExecutor(operation:)-7fqt1","title":"withMainSerialExecutor(operation:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"withMainSerialExecutor"},{"kind":"text","text":"("},{"kind":"externalParam","text":"operation"},{"kind":"text","text":": () "},{"kind":"keyword","text":"throws"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","preciseIdentifier":"s:s4Voida","text":"Void"},{"kind":"text","text":") "},{"kind":"keyword","text":"rethrows"}],"url":"\/documentation\/concurrencyextras\/withmainserialexecutor(operation:)-7fqt1","kind":"symbol","abstract":[{"type":"text","text":"Perform an operation on the main serial executor."}],"type":"topic","role":"symbol"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras":{"url":"\/documentation\/concurrencyextras","kind":"symbol","role":"collection","type":"topic","abstract":[{"type":"text","text":"Useful, testable Swift concurrency."}],"identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras","title":"ConcurrencyExtras"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/LockIsolated":{"url":"\/documentation\/concurrencyextras\/lockisolated","abstract":[{"type":"text","text":"A generic wrapper for isolating a mutable value with a lock."}],"kind":"symbol","title":"LockIsolated","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/LockIsolated","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"LockIsolated"}],"type":"topic","fragments":[{"kind":"keyword","text":"class"},{"text":" ","kind":"text"},{"kind":"identifier","text":"LockIsolated"}]},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/ReliablyTestingAsync":{"kind":"article","title":"Reliably testing async code","role":"article","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/ReliablyTestingAsync","type":"topic","abstract":[{"type":"text","text":"Learn how to use the tools of this library to write reliable, deterministic tests for your async"},{"text":" ","type":"text"},{"text":"Swift code.","type":"text"}],"url":"\/documentation\/concurrencyextras\/reliablytestingasync"},"https://forums.swift.org/t/reliably-testing-code-that-adopts-swift-concurrency/57304":{"type":"link","identifier":"https:\/\/forums.swift.org\/t\/reliably-testing-code-that-adopts-swift-concurrency\/57304","titleInlineContent":[{"text":"notoriously difficult","type":"text"}],"title":"notoriously difficult","url":"https:\/\/forums.swift.org\/t\/reliably-testing-code-that-adopts-swift-concurrency\/57304"},"https://github.com/apple/swift-evolution/blob/main/proposals/0302-concurrent-value-and-concurrent-closures.md#adaptor-types-for-legacy-codebases":{"type":"link","identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0302-concurrent-value-and-concurrent-closures.md#adaptor-types-for-legacy-codebases","titleInlineContent":[{"text":"“Adaptor Types for Legacy","type":"text"},{"text":" ","type":"text"},{"text":"Codebases”","type":"text"}],"title":"“Adaptor Types for Legacy Codebases”","url":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0302-concurrent-value-and-concurrent-closures.md#adaptor-types-for-legacy-codebases"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/uncheckedUseMainSerialExecutor":{"identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/uncheckedUseMainSerialExecutor","title":"uncheckedUseMainSerialExecutor","fragments":[{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"uncheckedUseMainSerialExecutor"},{"kind":"text","text":": "},{"kind":"typeIdentifier","preciseIdentifier":"s:Sb","text":"Bool"}],"url":"\/documentation\/concurrencyextras\/uncheckedusemainserialexecutor","kind":"symbol","abstract":[{"text":"Overrides Swift’s global executor with the main serial executor in an unchecked fashion.","type":"text"}],"type":"topic","role":"symbol"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/AnyHashableSendable":{"url":"\/documentation\/concurrencyextras\/anyhashablesendable","kind":"symbol","role":"symbol","type":"topic","abstract":[{"type":"text","text":"A type-erased hashable, sendable value."}],"fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"AnyHashableSendable"}],"identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/AnyHashableSendable","title":"AnyHashableSendable","navigatorTitle":[{"kind":"identifier","text":"AnyHashableSendable"}]},"https://github.com/apple/swift-evolution/blob/main/proposals/0302-concurrent-value-and-concurrent-closures.md":{"type":"link","identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0302-concurrent-value-and-concurrent-closures.md","titleInlineContent":[{"text":"SE-0302","type":"text"}],"title":"SE-0302","url":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0302-concurrent-value-and-concurrent-closures.md"}}}