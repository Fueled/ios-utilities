{"sections":[],"schemaVersion":{"patch":0,"major":0,"minor":3},"primaryContentSections":[{"content":[{"anchor":"Overview","type":"heading","text":"Overview","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"This library comes with a number of tools that make working with Swift concurrency easier and more"},{"type":"text","text":" "},{"type":"text","text":"testable."}]},{"anchor":"LockIsolated","type":"heading","text":"LockIsolated","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"code":"LockIsolated","type":"codeVoice"},{"type":"text","text":" type helps wrap other values in an isolated context. It wraps the value in a"},{"type":"text","text":" "},{"type":"text","text":"class with a lock, which allows you to read and write the value with a synchronous interface."}]},{"anchor":"Streams","type":"heading","text":"Streams","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"The library comes with numerous helper APIs spread across the two Swift stream types:"}]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"There are helpers that erase any "},{"type":"codeVoice","code":"AsyncSequence"},{"type":"text","text":" conformance to either concrete stream type."},{"type":"text","text":" "},{"type":"text","text":"This allows you to treat the stream type as a kind of “type erased” "},{"type":"codeVoice","code":"AsyncSequence"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"For example, suppose you have a dependency client like this:"}],"type":"paragraph"},{"code":["struct ScreenshotsClient {","  var screenshots: () -> AsyncStream<Void>","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"Then you can construct a live implementation that “erases” the"},{"type":"text","text":" "},{"type":"codeVoice","code":"NotificationCenter.Notifications"},{"type":"text","text":" async sequence to a stream:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["extension ScreenshotsClient {","  static let live = Self(","    screenshots: {","      NotificationCenter.default","        .notifications(named: UIApplication.userDidTakeScreenshotNotification)","        .map { _ in }","        .eraseToStream()  \/\/ ⬅️","    }","  )","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Use "},{"type":"codeVoice","code":"eraseToThrowingStream()"},{"type":"text","text":" to propagate failures from throwing async sequences."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"There is an API for simultaneously constructing a stream and its backing continuation. This can","type":"text"},{"text":" ","type":"text"},{"text":"be handy in tests when overriding a dependency endpoint that returns a stream:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["let screenshots = AsyncStream<Void>.streamWithContinuation()","let model = FeatureModel(screenshots: screenshots.stream)","","XCTAssertEqual(model.screenshotCount, 0)","screenshots.continuation.yield()  \/\/ Simulate a screenshot being taken.","XCTAssertEqual(model.screenshotCount, 1)"]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Static ","type":"text"},{"type":"codeVoice","code":"AsyncStream.never"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"AsyncThrowingStream.never"},{"text":" helpers are provided that represent","type":"text"},{"text":" ","type":"text"},{"text":"streams that live forever and never emit. They can be handy in tests that need to override a","type":"text"},{"text":" ","type":"text"},{"text":"dependency endpoint with a stream that should suspend and never emit for the duration test.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Static ","type":"text"},{"type":"codeVoice","code":"AsyncStream.finished"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"AsyncThrowingStream.finished(throwing:)"},{"text":" helpers are provided","type":"text"},{"text":" ","type":"text"},{"text":"that represents streams that complete immediately without emitting. They can be handy in tests","type":"text"},{"text":" ","type":"text"},{"text":"that need to override a dependency endpoint with a stream that completes\/fails immediately.","type":"text"}]}]}],"type":"unorderedList"},{"anchor":"Tasks","type":"heading","text":"Tasks","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"The library comes with a static function, "},{"type":"codeVoice","code":"Task.never()"},{"type":"text","text":", that can asynchronously return a value of"},{"type":"text","text":" "},{"type":"text","text":"any type, but does so by suspending forever. This can be useful for satisfying a dependency"},{"type":"text","text":" "},{"type":"text","text":"requirement in a way that does not require you to actually return data from that endpoint."}]},{"anchor":"UncheckedSendable","type":"heading","text":"UncheckedSendable","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"A wrapper type that can make any type "},{"type":"codeVoice","code":"Sendable"},{"type":"text","text":", but in an unsafe and unchecked way. This type"},{"type":"text","text":" "},{"type":"text","text":"should only be used as an alternative to "},{"type":"codeVoice","code":"@preconcurrency import"},{"type":"text","text":", which turns off concurrency"},{"type":"text","text":" "},{"type":"text","text":"checks for everything in the library. Whereas "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/UncheckedSendable"},{"type":"text","text":" allows you to turn off"},{"type":"text","text":" "},{"type":"text","text":"concurrency warnings for just one single usage of a particular type."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"While "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0302-concurrent-value-and-concurrent-closures.md"},{"type":"text","text":" mentions future work of "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0302-concurrent-value-and-concurrent-closures.md#adaptor-types-for-legacy-codebases"},{"type":"text","text":", including an "},{"type":"codeVoice","code":"UnsafeTransfer"},{"type":"text","text":" type that serves the same"},{"type":"text","text":" "},{"type":"text","text":"purpose, it has not landed in Swift."}]},{"anchor":"Serial-execution","type":"heading","text":"Serial execution","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"Some asynchronous code is "},{"type":"reference","isActive":true,"identifier":"https:\/\/forums.swift.org\/t\/reliably-testing-code-that-adopts-swift-concurrency\/57304"},{"type":"text","text":" to test in"},{"type":"text","text":" "},{"type":"text","text":"Swift due to how suspension points are processed by the runtime. The library comes with a static"},{"type":"text","text":" "},{"type":"text","text":"function, "},{"type":"codeVoice","code":"withMainSerialExecutor(operation:)-79jpc"},{"type":"text","text":", that runs all tasks spawned in an operation"},{"type":"text","text":" "},{"type":"text","text":"serially and deterministically. This function can be used to make asynchronous tests faster and less"},{"type":"text","text":" "},{"type":"text","text":"flakey."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that running async tasks serially does not mean that multiple concurrent tasks are not able to"},{"type":"text","text":" "},{"type":"text","text":"interleave. Suspension of async tasks still works just as you would expect, but all tasks are run on"},{"type":"text","text":" "},{"type":"text","text":"the unique, main thread."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, consider the following simple "},{"type":"codeVoice","code":"ObservableObject"},{"type":"text","text":" implementation for a feature that"},{"type":"text","text":" "},{"type":"text","text":"wants to count the number of times a screenshot is taken of the screen:"}]},{"code":["class FeatureModel: ObservableObject {","  @Published var count = 0","  @MainActor","  func onAppear() async {","    let screenshots = NotificationCenter.default.notifications(","      named: UIApplication.userDidTakeScreenshotNotification","    )","    for await _ in screenshots {","      self.count += 1","    }","  }","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is quite a simple feature, but in the future it could start doing more complicated things,"},{"type":"text","text":" "},{"type":"text","text":"such as performing a network request when it detects a screenshot being taken."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"So, it would be great if we could get some test coverage on this feature. To do this we can create"},{"type":"text","text":" "},{"type":"text","text":"a model, and spin up a new task to invoke the "},{"type":"codeVoice","code":"onAppear"},{"type":"text","text":" method:"}]},{"code":["func testBasics() async {","  let model = ViewModel()","  let task = Task { await model.onAppear() }","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then we can use "},{"type":"codeVoice","code":"Task.yield()"},{"type":"text","text":" to allow the subscription of the stream of notifications to start:"}]},{"code":["func testBasics() async {","  let model = ViewModel()","  let task = Task { await model.onAppear() }","","  \/\/ Give the task an opportunity to start executing its work.","  await Task.yield()","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then we can simulate the user taking a screenshot by posting a notification:"}]},{"code":["func testBasics() async {","  let model = ViewModel()","  let task = Task { await model.onAppear() }","","  \/\/ Give the task an opportunity to start executing its work.","  await Task.yield()","","  \/\/ Simulate a screen shot being taken.","  NotificationCenter.default.post(","    name: UIApplication.userDidTakeScreenshotNotification, object: nil","  )","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"And then finally we can yield again to process the new notification and assert that the count"},{"type":"text","text":" "},{"type":"text","text":"incremented by 1:"}]},{"code":["func testBasics() async {","  let model = ViewModel()","  let task = Task { await model.onAppear() }","","  \/\/ Give the task an opportunity to start executing its work.","  await Task.yield()","","  \/\/ Simulate a screen shot being taken.","  NotificationCenter.default.post(","    name: UIApplication.userDidTakeScreenshotNotification, object: nil","  )","","  \/\/ Give the task an opportunity to update the view model.","  await Task.yield()","","  XCTAssertEqual(model.count, 1)","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This seems like a perfectly reasonable test, and it does pass… sometimes. If you run it enough"},{"type":"text","text":" "},{"type":"text","text":"times you will eventually get a failure (about 6% of the time). This is happening because sometimes"},{"type":"text","text":" "},{"type":"text","text":"the single "},{"type":"codeVoice","code":"Task.yield()"},{"type":"text","text":" is not enough for the subscription to the stream of notifications to"},{"type":"text","text":" "},{"type":"text","text":"actually start. In that case we will post the notification before we have actually subscribed,"},{"type":"text","text":" "},{"type":"text","text":"causing a test failure."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If we wrap the entire test in "},{"type":"codeVoice","code":"withMainSerialExecutor(operation:)-79jpc"},{"type":"text","text":", then it will pass"},{"type":"text","text":" "},{"type":"text","text":"deterministically, 100% of the time:"}]},{"code":["func testBasics() async {","  await withMainSerialExecutor {","    …","  }","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is because now all tasks are enqueued on the serial, main executor, and so when we "},{"type":"codeVoice","code":"Task.yield"},{"type":"text","text":" "},{"type":"text","text":"we can be sure that the "},{"type":"codeVoice","code":"onAppear"},{"type":"text","text":" method will execute until it reaches a suspension point. This"},{"type":"text","text":" "},{"type":"text","text":"guarantees that the subscription to the stream of notifications will start when we expect it to."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can also use "},{"type":"reference","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/withMainSerialExecutor(operation:)-7fqt1","isActive":true},{"type":"text","text":" to wrap an entire test case by"},{"type":"text","text":" "},{"type":"text","text":"overriding the "},{"type":"codeVoice","code":"invokeTest"},{"type":"text","text":" method:"}]},{"code":["final class FeatureModelTests: XCTestCase {","  override func invokeTest() {","    withMainSerialExecutor {","      super.invokeTest()","    }","  }","  …","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now the entire "},{"type":"codeVoice","code":"FeatureModelTests"},{"type":"text","text":" test case will be run on the main, serial executor."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that by using "},{"type":"codeVoice","code":"withMainSerialExecutor(operation:)-79jpc"},{"type":"text","text":" you are technically making your"},{"type":"text","text":" "},{"type":"text","text":"tests behave in a manner that is different from how they would run in production. However, many"},{"type":"text","text":" "},{"type":"text","text":"tests written on a day-to-day basis due not invoke the full-blown vagaries of concurrency. Instead"},{"type":"text","text":" "},{"type":"text","text":"the tests want to assert that some user action happens, an async unit of work is executed, and"},{"type":"text","text":" "},{"type":"text","text":"that causes some state to change. Such tests should be written in a way that is 100% deterministic."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If your code has truly complex asynchronous and concurrent operations, then it may be handy to write"},{"type":"text","text":" "},{"type":"text","text":"two sets of tests: one set that targets the main executor (using"},{"type":"text","text":" "},{"type":"codeVoice","code":"withMainSerialExecutor(operation:)-79jpc"},{"type":"text","text":") so that you can deterministically assert how the core"},{"type":"text","text":" "},{"type":"text","text":"system behaves, and then another set that targets the default, global executor that will probably"},{"type":"text","text":" "},{"type":"text","text":"need to make weaker assertions due to non-determinism, but can still assert on some things."}]}],"kind":"content"}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras"},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/concurrencyextras"]}],"metadata":{"symbolKind":"module","role":"collection","externalID":"ConcurrencyExtras","title":"ConcurrencyExtras","modules":[{"name":"ConcurrencyExtras"}],"roleHeading":"Framework"},"abstract":[{"type":"text","text":"Useful, testable Swift concurrency."}],"topicSections":[{"title":"Data races","anchor":"Data-races","identifiers":["doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/LockIsolated","doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/AnyHashableSendable"]},{"title":"Serial execution","anchor":"Serial-execution","identifiers":["doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/ReliablyTestingAsync"]},{"title":"Preconcurrency","anchor":"Preconcurrency","identifiers":["doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/UncheckedSendable"]},{"title":"Articles","generated":true,"anchor":"Articles","identifiers":["doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/ActorIsolatedDeprecations"]},{"title":"Variables","generated":true,"anchor":"Variables","identifiers":["doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/uncheckedUseMainSerialExecutor"]},{"title":"Functions","generated":true,"anchor":"Functions","identifiers":["doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/withMainSerialExecutor(operation:)-6s3c0","doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/withMainSerialExecutor(operation:)-7fqt1"]},{"title":"Extended Modules","generated":true,"anchor":"Extended-Modules","identifiers":["doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/Swift","doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/_Concurrency"]}],"hierarchy":{"paths":[[]]},"kind":"symbol","references":{"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/withMainSerialExecutor(operation:)-7fqt1":{"fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"withMainSerialExecutor"},{"kind":"text","text":"("},{"kind":"externalParam","text":"operation"},{"kind":"text","text":": () "},{"kind":"keyword","text":"throws"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"Void","preciseIdentifier":"s:s4Voida"},{"kind":"text","text":") "},{"kind":"keyword","text":"rethrows"}],"url":"\/documentation\/concurrencyextras\/withmainserialexecutor(operation:)-7fqt1","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/withMainSerialExecutor(operation:)-7fqt1","title":"withMainSerialExecutor(operation:)","type":"topic","role":"symbol","abstract":[{"type":"text","text":"Perform an operation on the main serial executor."}],"kind":"symbol"},"https://github.com/apple/swift-evolution/blob/main/proposals/0302-concurrent-value-and-concurrent-closures.md":{"title":"SE-0302","type":"link","identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0302-concurrent-value-and-concurrent-closures.md","url":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0302-concurrent-value-and-concurrent-closures.md","titleInlineContent":[{"type":"text","text":"SE-0302"}]},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/ActorIsolatedDeprecations":{"url":"\/documentation\/concurrencyextras\/actorisolateddeprecations","type":"topic","title":"Deprecations","role":"collectionGroup","abstract":[{"type":"text","text":"Review unsupported reducer APIs and their replacements."}],"kind":"article","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/ActorIsolatedDeprecations"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras":{"url":"\/documentation\/concurrencyextras","type":"topic","title":"ConcurrencyExtras","role":"collection","abstract":[{"type":"text","text":"Useful, testable Swift concurrency."}],"kind":"symbol","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/AnyHashableSendable":{"title":"AnyHashableSendable","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"AnyHashableSendable"}],"kind":"symbol","role":"symbol","url":"\/documentation\/concurrencyextras\/anyhashablesendable","navigatorTitle":[{"kind":"identifier","text":"AnyHashableSendable"}],"abstract":[{"type":"text","text":"A type-erased hashable, sendable value."}],"type":"topic","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/AnyHashableSendable"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/uncheckedUseMainSerialExecutor":{"fragments":[{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"uncheckedUseMainSerialExecutor"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Bool","preciseIdentifier":"s:Sb"}],"url":"\/documentation\/concurrencyextras\/uncheckedusemainserialexecutor","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/uncheckedUseMainSerialExecutor","title":"uncheckedUseMainSerialExecutor","type":"topic","role":"symbol","abstract":[{"type":"text","text":"Overrides Swift’s global executor with the main serial executor in an unchecked fashion."}],"kind":"symbol"},"https://github.com/apple/swift-evolution/blob/main/proposals/0302-concurrent-value-and-concurrent-closures.md#adaptor-types-for-legacy-codebases":{"title":"“Adaptor Types for Legacy Codebases”","type":"link","identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0302-concurrent-value-and-concurrent-closures.md#adaptor-types-for-legacy-codebases","url":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0302-concurrent-value-and-concurrent-closures.md#adaptor-types-for-legacy-codebases","titleInlineContent":[{"type":"text","text":"“Adaptor Types for Legacy"},{"type":"text","text":" "},{"type":"text","text":"Codebases”"}]},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/Swift":{"type":"topic","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/Swift","kind":"symbol","title":"Swift","url":"\/documentation\/concurrencyextras\/swift","abstract":[],"role":"collection"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/withMainSerialExecutor(operation:)-6s3c0":{"url":"\/documentation\/concurrencyextras\/withmainserialexecutor(operation:)-6s3c0","type":"topic","title":"withMainSerialExecutor(operation:)","role":"symbol","abstract":[{"type":"text","text":"Perform an operation on the main serial executor."}],"kind":"symbol","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/withMainSerialExecutor(operation:)-6s3c0","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"withMainSerialExecutor"},{"kind":"text","text":"("},{"kind":"externalParam","text":"operation"},{"kind":"text","text":": () "},{"kind":"keyword","text":"async"},{"kind":"text","text":" "},{"kind":"keyword","text":"throws"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"Void","preciseIdentifier":"s:s4Voida"},{"kind":"text","text":") "},{"kind":"keyword","text":"async"},{"kind":"text","text":" "},{"kind":"keyword","text":"rethrows"}]},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/ReliablyTestingAsync":{"url":"\/documentation\/concurrencyextras\/reliablytestingasync","type":"topic","title":"Reliably testing async code","role":"article","abstract":[{"type":"text","text":"Learn how to use the tools of this library to write reliable, deterministic tests for your async"},{"type":"text","text":" "},{"type":"text","text":"Swift code."}],"kind":"article","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/ReliablyTestingAsync"},"https://forums.swift.org/t/reliably-testing-code-that-adopts-swift-concurrency/57304":{"title":"notoriously difficult","type":"link","identifier":"https:\/\/forums.swift.org\/t\/reliably-testing-code-that-adopts-swift-concurrency\/57304","url":"https:\/\/forums.swift.org\/t\/reliably-testing-code-that-adopts-swift-concurrency\/57304","titleInlineContent":[{"type":"text","text":"notoriously difficult"}]},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/_Concurrency":{"url":"\/documentation\/concurrencyextras\/_concurrency","type":"topic","title":"_Concurrency","role":"collection","abstract":[],"kind":"symbol","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/_Concurrency"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/LockIsolated":{"role":"symbol","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"LockIsolated"}],"abstract":[{"type":"text","text":"A generic wrapper for isolating a mutable value with a lock."}],"navigatorTitle":[{"kind":"identifier","text":"LockIsolated"}],"type":"topic","kind":"symbol","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/LockIsolated","title":"LockIsolated","url":"\/documentation\/concurrencyextras\/lockisolated"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/UncheckedSendable":{"type":"topic","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/UncheckedSendable","kind":"symbol","title":"UncheckedSendable","url":"\/documentation\/concurrencyextras\/uncheckedsendable","deprecated":true,"navigatorTitle":[{"kind":"identifier","text":"UncheckedSendable"}],"abstract":[{"type":"text","text":"A generic wrapper for turning any non-"},{"type":"codeVoice","code":"Sendable"},{"type":"text","text":" type into a "},{"type":"codeVoice","code":"Sendable"},{"type":"text","text":" one, in an unchecked"},{"type":"text","text":" "},{"type":"text","text":"manner."}],"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"UncheckedSendable"}],"role":"symbol"}}}