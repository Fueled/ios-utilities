{"schemaVersion":{"major":0,"minor":3,"patch":0},"variants":[{"paths":["\/documentation\/concurrencyextras"],"traits":[{"interfaceLanguage":"swift"}]}],"abstract":[{"type":"text","text":"Useful, testable Swift concurrency."}],"kind":"symbol","hierarchy":{"paths":[[]]},"topicSections":[{"title":"Data races","identifiers":["doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/LockIsolated","doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/AnyHashableSendable"],"anchor":"Data-races"},{"title":"Serial execution","identifiers":["doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/ReliablyTestingAsync"],"anchor":"Serial-execution"},{"title":"Preconcurrency","identifiers":["doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/UncheckedSendable"],"anchor":"Preconcurrency"},{"title":"Articles","identifiers":["doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/ActorIsolatedDeprecations"],"anchor":"Articles","generated":true},{"title":"Variables","identifiers":["doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/uncheckedUseMainSerialExecutor"],"anchor":"Variables","generated":true},{"title":"Functions","identifiers":["doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/withMainSerialExecutor(operation:)-6s3c0","doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/withMainSerialExecutor(operation:)-7fqt1"],"anchor":"Functions","generated":true},{"title":"Extended Modules","identifiers":["doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/Swift","doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/_Concurrency"],"anchor":"Extended-Modules","generated":true}],"sections":[],"identifier":{"url":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras","interfaceLanguage":"swift"},"metadata":{"modules":[{"name":"ConcurrencyExtras"}],"symbolKind":"module","roleHeading":"Framework","title":"ConcurrencyExtras","role":"collection","externalID":"ConcurrencyExtras"},"primaryContentSections":[{"content":[{"type":"heading","text":"Overview","anchor":"Overview","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"This library comes with a number of tools that make working with Swift concurrency easier and more"},{"type":"text","text":" "},{"type":"text","text":"testable."}]},{"type":"heading","text":"LockIsolated","anchor":"LockIsolated","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"LockIsolated"},{"type":"text","text":" type helps wrap other values in an isolated context. It wraps the value in a"},{"type":"text","text":" "},{"type":"text","text":"class with a lock, which allows you to read and write the value with a synchronous interface."}]},{"type":"heading","text":"Streams","anchor":"Streams","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"The library comes with numerous helper APIs spread across the two Swift stream types:"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"There are helpers that erase any ","type":"text"},{"code":"AsyncSequence","type":"codeVoice"},{"text":" conformance to either concrete stream type.","type":"text"},{"text":" ","type":"text"},{"text":"This allows you to treat the stream type as a kind of “type erased” ","type":"text"},{"code":"AsyncSequence","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"For example, suppose you have a dependency client like this:","type":"text"}],"type":"paragraph"},{"code":["struct ScreenshotsClient {","  var screenshots: () -> AsyncStream<Void>","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"Then you can construct a live implementation that “erases” the","type":"text"},{"text":" ","type":"text"},{"code":"NotificationCenter.Notifications","type":"codeVoice"},{"text":" async sequence to a stream:","type":"text"}],"type":"paragraph"},{"code":["extension ScreenshotsClient {","  static let live = Self(","    screenshots: {","      NotificationCenter.default","        .notifications(named: UIApplication.userDidTakeScreenshotNotification)","        .map { _ in }","        .eraseToStream()  \/\/ ⬅️","    }","  )","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"Use ","type":"text"},{"code":"eraseToThrowingStream()","type":"codeVoice"},{"text":" to propagate failures from throwing async sequences.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"There is an API for simultaneously constructing a stream and its backing continuation. This can","type":"text"},{"text":" ","type":"text"},{"text":"be handy in tests when overriding a dependency endpoint that returns a stream:","type":"text"}],"type":"paragraph"},{"code":["let screenshots = AsyncStream<Void>.streamWithContinuation()","let model = FeatureModel(screenshots: screenshots.stream)","","XCTAssertEqual(model.screenshotCount, 0)","screenshots.continuation.yield()  \/\/ Simulate a screenshot being taken.","XCTAssertEqual(model.screenshotCount, 1)"],"type":"codeListing","syntax":"swift"}]},{"content":[{"inlineContent":[{"text":"Static ","type":"text"},{"code":"AsyncStream.never","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"AsyncThrowingStream.never","type":"codeVoice"},{"text":" helpers are provided that represent","type":"text"},{"text":" ","type":"text"},{"text":"streams that live forever and never emit. They can be handy in tests that need to override a","type":"text"},{"text":" ","type":"text"},{"text":"dependency endpoint with a stream that should suspend and never emit for the duration test.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Static ","type":"text"},{"code":"AsyncStream.finished","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"AsyncThrowingStream.finished(throwing:)","type":"codeVoice"},{"text":" helpers are provided","type":"text"},{"text":" ","type":"text"},{"text":"that represents streams that complete immediately without emitting. They can be handy in tests","type":"text"},{"text":" ","type":"text"},{"text":"that need to override a dependency endpoint with a stream that completes\/fails immediately.","type":"text"}],"type":"paragraph"}]}]},{"type":"heading","text":"Tasks","anchor":"Tasks","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"The library comes with a static function, "},{"type":"codeVoice","code":"Task.never()"},{"type":"text","text":", that can asynchronously return a value of"},{"type":"text","text":" "},{"type":"text","text":"any type, but does so by suspending forever. This can be useful for satisfying a dependency"},{"type":"text","text":" "},{"type":"text","text":"requirement in a way that does not require you to actually return data from that endpoint."}]},{"type":"heading","text":"UncheckedSendable","anchor":"UncheckedSendable","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"A wrapper type that can make any type "},{"type":"codeVoice","code":"Sendable"},{"type":"text","text":", but in an unsafe and unchecked way. This type"},{"type":"text","text":" "},{"type":"text","text":"should only be used as an alternative to "},{"type":"codeVoice","code":"@preconcurrency import"},{"type":"text","text":", which turns off concurrency"},{"type":"text","text":" "},{"type":"text","text":"checks for everything in the library. Whereas "},{"type":"reference","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/UncheckedSendable","isActive":true},{"type":"text","text":" allows you to turn off"},{"type":"text","text":" "},{"type":"text","text":"concurrency warnings for just one single usage of a particular type."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"While "},{"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0302-concurrent-value-and-concurrent-closures.md","isActive":true},{"type":"text","text":" mentions future work of "},{"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0302-concurrent-value-and-concurrent-closures.md#adaptor-types-for-legacy-codebases","isActive":true},{"type":"text","text":", including an "},{"type":"codeVoice","code":"UnsafeTransfer"},{"type":"text","text":" type that serves the same"},{"type":"text","text":" "},{"type":"text","text":"purpose, it has not landed in Swift."}]},{"type":"heading","text":"Serial execution","anchor":"Serial-execution","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"Some asynchronous code is "},{"type":"reference","identifier":"https:\/\/forums.swift.org\/t\/reliably-testing-code-that-adopts-swift-concurrency\/57304","isActive":true},{"type":"text","text":" to test in"},{"type":"text","text":" "},{"type":"text","text":"Swift due to how suspension points are processed by the runtime. The library comes with a static"},{"type":"text","text":" "},{"type":"text","text":"function, "},{"type":"codeVoice","code":"withMainSerialExecutor(operation:)-79jpc"},{"type":"text","text":", that runs all tasks spawned in an operation"},{"type":"text","text":" "},{"type":"text","text":"serially and deterministically. This function can be used to make asynchronous tests faster and less"},{"type":"text","text":" "},{"type":"text","text":"flakey."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that running async tasks serially does not mean that multiple concurrent tasks are not able to"},{"type":"text","text":" "},{"type":"text","text":"interleave. Suspension of async tasks still works just as you would expect, but all tasks are run on"},{"type":"text","text":" "},{"type":"text","text":"the unique, main thread."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, consider the following simple "},{"type":"codeVoice","code":"ObservableObject"},{"type":"text","text":" implementation for a feature that"},{"type":"text","text":" "},{"type":"text","text":"wants to count the number of times a screenshot is taken of the screen:"}]},{"type":"codeListing","code":["class FeatureModel: ObservableObject {","  @Published var count = 0","  @MainActor","  func onAppear() async {","    let screenshots = NotificationCenter.default.notifications(","      named: UIApplication.userDidTakeScreenshotNotification","    )","    for await _ in screenshots {","      self.count += 1","    }","  }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is quite a simple feature, but in the future it could start doing more complicated things,"},{"type":"text","text":" "},{"type":"text","text":"such as performing a network request when it detects a screenshot being taken."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"So, it would be great if we could get some test coverage on this feature. To do this we can create"},{"type":"text","text":" "},{"type":"text","text":"a model, and spin up a new task to invoke the "},{"type":"codeVoice","code":"onAppear"},{"type":"text","text":" method:"}]},{"type":"codeListing","code":["func testBasics() async {","  let model = ViewModel()","  let task = Task { await model.onAppear() }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then we can use "},{"type":"codeVoice","code":"Task.yield()"},{"type":"text","text":" to allow the subscription of the stream of notifications to start:"}]},{"type":"codeListing","code":["func testBasics() async {","  let model = ViewModel()","  let task = Task { await model.onAppear() }","","  \/\/ Give the task an opportunity to start executing its work.","  await Task.yield()","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then we can simulate the user taking a screenshot by posting a notification:"}]},{"type":"codeListing","code":["func testBasics() async {","  let model = ViewModel()","  let task = Task { await model.onAppear() }","","  \/\/ Give the task an opportunity to start executing its work.","  await Task.yield()","","  \/\/ Simulate a screen shot being taken.","  NotificationCenter.default.post(","    name: UIApplication.userDidTakeScreenshotNotification, object: nil","  )","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"And then finally we can yield again to process the new notification and assert that the count"},{"type":"text","text":" "},{"type":"text","text":"incremented by 1:"}]},{"type":"codeListing","code":["func testBasics() async {","  let model = ViewModel()","  let task = Task { await model.onAppear() }","","  \/\/ Give the task an opportunity to start executing its work.","  await Task.yield()","","  \/\/ Simulate a screen shot being taken.","  NotificationCenter.default.post(","    name: UIApplication.userDidTakeScreenshotNotification, object: nil","  )","","  \/\/ Give the task an opportunity to update the view model.","  await Task.yield()","","  XCTAssertEqual(model.count, 1)","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This seems like a perfectly reasonable test, and it does pass… sometimes. If you run it enough"},{"type":"text","text":" "},{"type":"text","text":"times you will eventually get a failure (about 6% of the time). This is happening because sometimes"},{"type":"text","text":" "},{"type":"text","text":"the single "},{"type":"codeVoice","code":"Task.yield()"},{"type":"text","text":" is not enough for the subscription to the stream of notifications to"},{"type":"text","text":" "},{"type":"text","text":"actually start. In that case we will post the notification before we have actually subscribed,"},{"type":"text","text":" "},{"type":"text","text":"causing a test failure."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If we wrap the entire test in "},{"type":"codeVoice","code":"withMainSerialExecutor(operation:)-79jpc"},{"type":"text","text":", then it will pass"},{"type":"text","text":" "},{"type":"text","text":"deterministically, 100% of the time:"}]},{"type":"codeListing","code":["func testBasics() async {","  await withMainSerialExecutor {","    …","  }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is because now all tasks are enqueued on the serial, main executor, and so when we "},{"type":"codeVoice","code":"Task.yield"},{"type":"text","text":" "},{"type":"text","text":"we can be sure that the "},{"type":"codeVoice","code":"onAppear"},{"type":"text","text":" method will execute until it reaches a suspension point. This"},{"type":"text","text":" "},{"type":"text","text":"guarantees that the subscription to the stream of notifications will start when we expect it to."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can also use "},{"type":"reference","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/withMainSerialExecutor(operation:)-7fqt1","isActive":true},{"type":"text","text":" to wrap an entire test case by"},{"type":"text","text":" "},{"type":"text","text":"overriding the "},{"type":"codeVoice","code":"invokeTest"},{"type":"text","text":" method:"}]},{"type":"codeListing","code":["final class FeatureModelTests: XCTestCase {","  override func invokeTest() {","    withMainSerialExecutor {","      super.invokeTest()","    }","  }","  …","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now the entire "},{"type":"codeVoice","code":"FeatureModelTests"},{"type":"text","text":" test case will be run on the main, serial executor."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that by using "},{"type":"codeVoice","code":"withMainSerialExecutor(operation:)-79jpc"},{"type":"text","text":" you are technically making your"},{"type":"text","text":" "},{"type":"text","text":"tests behave in a manner that is different from how they would run in production. However, many"},{"type":"text","text":" "},{"type":"text","text":"tests written on a day-to-day basis due not invoke the full-blown vagaries of concurrency. Instead"},{"type":"text","text":" "},{"type":"text","text":"the tests want to assert that some user action happens, an async unit of work is executed, and"},{"type":"text","text":" "},{"type":"text","text":"that causes some state to change. Such tests should be written in a way that is 100% deterministic."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If your code has truly complex asynchronous and concurrent operations, then it may be handy to write"},{"type":"text","text":" "},{"type":"text","text":"two sets of tests: one set that targets the main executor (using"},{"type":"text","text":" "},{"type":"codeVoice","code":"withMainSerialExecutor(operation:)-79jpc"},{"type":"text","text":") so that you can deterministically assert how the core"},{"type":"text","text":" "},{"type":"text","text":"system behaves, and then another set that targets the default, global executor that will probably"},{"type":"text","text":" "},{"type":"text","text":"need to make weaker assertions due to non-determinism, but can still assert on some things."}]}],"kind":"content"}],"references":{"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/Swift":{"url":"\/documentation\/concurrencyextras\/swift","abstract":[],"title":"Swift","kind":"symbol","type":"topic","role":"collection","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/Swift"},"https://github.com/apple/swift-evolution/blob/main/proposals/0302-concurrent-value-and-concurrent-closures.md":{"title":"SE-0302","titleInlineContent":[{"type":"text","text":"SE-0302"}],"identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0302-concurrent-value-and-concurrent-closures.md","url":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0302-concurrent-value-and-concurrent-closures.md","type":"link"},"https://forums.swift.org/t/reliably-testing-code-that-adopts-swift-concurrency/57304":{"title":"notoriously difficult","titleInlineContent":[{"type":"text","text":"notoriously difficult"}],"identifier":"https:\/\/forums.swift.org\/t\/reliably-testing-code-that-adopts-swift-concurrency\/57304","url":"https:\/\/forums.swift.org\/t\/reliably-testing-code-that-adopts-swift-concurrency\/57304","type":"link"},"https://github.com/apple/swift-evolution/blob/main/proposals/0302-concurrent-value-and-concurrent-closures.md#adaptor-types-for-legacy-codebases":{"title":"“Adaptor Types for Legacy Codebases”","titleInlineContent":[{"type":"text","text":"“Adaptor Types for Legacy"},{"type":"text","text":" "},{"type":"text","text":"Codebases”"}],"identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0302-concurrent-value-and-concurrent-closures.md#adaptor-types-for-legacy-codebases","url":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0302-concurrent-value-and-concurrent-closures.md#adaptor-types-for-legacy-codebases","type":"link"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/withMainSerialExecutor(operation:)-7fqt1":{"title":"withMainSerialExecutor(operation:)","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/withMainSerialExecutor(operation:)-7fqt1","fragments":[{"text":"func","kind":"keyword"},{"kind":"text","text":" "},{"text":"withMainSerialExecutor","kind":"identifier"},{"text":"(","kind":"text"},{"text":"operation","kind":"externalParam"},{"text":": () ","kind":"text"},{"text":"throws","kind":"keyword"},{"text":" -> ","kind":"text"},{"preciseIdentifier":"s:s4Voida","text":"Void","kind":"typeIdentifier"},{"text":") ","kind":"text"},{"text":"rethrows","kind":"keyword"}],"role":"symbol","type":"topic","abstract":[{"type":"text","text":"Perform an operation on the main serial executor."}],"kind":"symbol","url":"\/documentation\/concurrencyextras\/withmainserialexecutor(operation:)-7fqt1"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/ReliablyTestingAsync":{"url":"\/documentation\/concurrencyextras\/reliablytestingasync","abstract":[{"type":"text","text":"Learn how to use the tools of this library to write reliable, deterministic tests for your async"},{"type":"text","text":" "},{"type":"text","text":"Swift code."}],"title":"Reliably testing async code","kind":"article","type":"topic","role":"article","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/ReliablyTestingAsync"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/LockIsolated":{"abstract":[{"text":"A generic wrapper for isolating a mutable value with a lock.","type":"text"}],"kind":"symbol","title":"LockIsolated","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/LockIsolated","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"LockIsolated","kind":"identifier"}],"type":"topic","navigatorTitle":[{"text":"LockIsolated","kind":"identifier"}],"url":"\/documentation\/concurrencyextras\/lockisolated","role":"symbol"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/ActorIsolatedDeprecations":{"url":"\/documentation\/concurrencyextras\/actorisolateddeprecations","type":"topic","title":"Deprecations","abstract":[{"type":"text","text":"Review unsupported reducer APIs and their replacements."}],"kind":"article","role":"collectionGroup","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/ActorIsolatedDeprecations"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/uncheckedUseMainSerialExecutor":{"url":"\/documentation\/concurrencyextras\/uncheckedusemainserialexecutor","type":"topic","title":"uncheckedUseMainSerialExecutor","abstract":[{"type":"text","text":"Overrides Swift’s global executor with the main serial executor in an unchecked fashion."}],"kind":"symbol","role":"symbol","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/uncheckedUseMainSerialExecutor","fragments":[{"text":"var","kind":"keyword"},{"text":" ","kind":"text"},{"text":"uncheckedUseMainSerialExecutor","kind":"identifier"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:Sb","text":"Bool","kind":"typeIdentifier"}]},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras":{"url":"\/documentation\/concurrencyextras","abstract":[{"text":"Useful, testable Swift concurrency.","type":"text"}],"title":"ConcurrencyExtras","kind":"symbol","type":"topic","role":"collection","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/AnyHashableSendable":{"url":"\/documentation\/concurrencyextras\/anyhashablesendable","abstract":[{"text":"A type-erased hashable, sendable value.","type":"text"}],"title":"AnyHashableSendable","type":"topic","kind":"symbol","navigatorTitle":[{"text":"AnyHashableSendable","kind":"identifier"}],"role":"symbol","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/AnyHashableSendable","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"AnyHashableSendable","kind":"identifier"}]},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/withMainSerialExecutor(operation:)-6s3c0":{"url":"\/documentation\/concurrencyextras\/withmainserialexecutor(operation:)-6s3c0","abstract":[{"type":"text","text":"Perform an operation on the main serial executor."}],"title":"withMainSerialExecutor(operation:)","kind":"symbol","type":"topic","role":"symbol","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/withMainSerialExecutor(operation:)-6s3c0","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"withMainSerialExecutor","kind":"identifier"},{"text":"(","kind":"text"},{"text":"operation","kind":"externalParam"},{"text":": () ","kind":"text"},{"text":"async","kind":"keyword"},{"text":" ","kind":"text"},{"text":"throws","kind":"keyword"},{"text":" -> ","kind":"text"},{"text":"Void","kind":"typeIdentifier","preciseIdentifier":"s:s4Voida"},{"text":") ","kind":"text"},{"text":"async","kind":"keyword"},{"text":" ","kind":"text"},{"text":"rethrows","kind":"keyword"}]},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/_Concurrency":{"url":"\/documentation\/concurrencyextras\/_concurrency","type":"topic","title":"_Concurrency","abstract":[],"kind":"symbol","role":"collection","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/_Concurrency"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/UncheckedSendable":{"url":"\/documentation\/concurrencyextras\/uncheckedsendable","type":"topic","title":"UncheckedSendable","abstract":[{"text":"A generic wrapper for turning any non-","type":"text"},{"code":"Sendable","type":"codeVoice"},{"text":" type into a ","type":"text"},{"code":"Sendable","type":"codeVoice"},{"text":" one, in an unchecked","type":"text"},{"text":" ","type":"text"},{"text":"manner.","type":"text"}],"kind":"symbol","navigatorTitle":[{"text":"UncheckedSendable","kind":"identifier"}],"deprecated":true,"role":"symbol","identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/UncheckedSendable","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"UncheckedSendable","kind":"identifier"}]}}}