{"metadata":{"roleHeading":"Framework","role":"collection","symbolKind":"module","modules":[{"name":"FueledSwiftConcurrency"}],"externalID":"FueledSwiftConcurrency","title":"FueledSwiftConcurrency"},"sections":[],"schemaVersion":{"major":0,"minor":3,"patch":0},"topicSections":[{"identifiers":["doc:\/\/FueledSwiftConcurrency\/documentation\/FueledSwiftConcurrency\/AsyncCache","doc:\/\/FueledSwiftConcurrency\/documentation\/FueledSwiftConcurrency\/AsyncSemaphore","doc:\/\/FueledSwiftConcurrency\/documentation\/FueledSwiftConcurrency\/BroadcastStream","doc:\/\/FueledSwiftConcurrency\/documentation\/FueledSwiftConcurrency\/BufferedStream","doc:\/\/FueledSwiftConcurrency\/documentation\/FueledSwiftConcurrency\/CurrentValueAsyncSubject"],"generated":true,"anchor":"Classes","title":"Classes"},{"identifiers":["doc:\/\/FueledSwiftConcurrency\/documentation\/FueledSwiftConcurrency\/BufferedStreamIterator","doc:\/\/FueledSwiftConcurrency\/documentation\/FueledSwiftConcurrency\/TakeUntilAsyncSequence","doc:\/\/FueledSwiftConcurrency\/documentation\/FueledSwiftConcurrency\/TimeoutAsyncSequence"],"generated":true,"anchor":"Structures","title":"Structures"},{"identifiers":["doc:\/\/FueledSwiftConcurrency\/documentation\/FueledSwiftConcurrency\/_Concurrency"],"generated":true,"anchor":"Extended-Modules","title":"Extended Modules"}],"hierarchy":{"paths":[[]]},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/FueledSwiftConcurrency\/documentation\/FueledSwiftConcurrency"},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/fueledswiftconcurrency"]}],"kind":"symbol","references":{"doc://FueledSwiftConcurrency/documentation/FueledSwiftConcurrency/CurrentValueAsyncSubject":{"type":"topic","role":"symbol","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"CurrentValueAsyncSubject","kind":"identifier"}],"navigatorTitle":[{"text":"CurrentValueAsyncSubject","kind":"identifier"}],"identifier":"doc:\/\/FueledSwiftConcurrency\/documentation\/FueledSwiftConcurrency\/CurrentValueAsyncSubject","url":"\/documentation\/fueledswiftconcurrency\/currentvalueasyncsubject","kind":"symbol","title":"CurrentValueAsyncSubject","abstract":[{"text":"A thread-safe subject that holds a current value and broadcasts changes to subscribers.","type":"text"}]},"doc://FueledSwiftConcurrency/documentation/FueledSwiftConcurrency/TakeUntilAsyncSequence":{"identifier":"doc:\/\/FueledSwiftConcurrency\/documentation\/FueledSwiftConcurrency\/TakeUntilAsyncSequence","navigatorTitle":[{"text":"TakeUntilAsyncSequence","kind":"identifier"}],"abstract":[{"text":"An async sequence that emits elements until a condition is met.","type":"text"}],"type":"topic","url":"\/documentation\/fueledswiftconcurrency\/takeuntilasyncsequence","kind":"symbol","role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"TakeUntilAsyncSequence","kind":"identifier"}],"title":"TakeUntilAsyncSequence"},"doc://FueledSwiftConcurrency/documentation/FueledSwiftConcurrency/BroadcastStream":{"identifier":"doc:\/\/FueledSwiftConcurrency\/documentation\/FueledSwiftConcurrency\/BroadcastStream","navigatorTitle":[{"text":"BroadcastStream","kind":"identifier"}],"type":"topic","abstract":[{"type":"text","text":"A thread-safe broadcast stream that emits values to multiple subscribers."}],"url":"\/documentation\/fueledswiftconcurrency\/broadcaststream","kind":"symbol","role":"symbol","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"BroadcastStream","kind":"identifier"}],"title":"BroadcastStream"},"doc://FueledSwiftConcurrency/documentation/FueledSwiftConcurrency/BufferedStreamIterator":{"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"BufferedStreamIterator"}],"title":"BufferedStreamIterator","role":"symbol","abstract":[{"type":"text","text":"An async iterator for "},{"type":"codeVoice","code":"BufferedStream"},{"type":"text","text":"."}],"kind":"symbol","url":"\/documentation\/fueledswiftconcurrency\/bufferedstreamiterator","identifier":"doc:\/\/FueledSwiftConcurrency\/documentation\/FueledSwiftConcurrency\/BufferedStreamIterator","type":"topic","navigatorTitle":[{"text":"BufferedStreamIterator","kind":"identifier"}]},"doc://FueledSwiftConcurrency/documentation/FueledSwiftConcurrency":{"identifier":"doc:\/\/FueledSwiftConcurrency\/documentation\/FueledSwiftConcurrency","abstract":[],"url":"\/documentation\/fueledswiftconcurrency","title":"FueledSwiftConcurrency","kind":"symbol","type":"topic","role":"collection"},"doc://FueledSwiftConcurrency/documentation/FueledSwiftConcurrency/BufferedStream":{"role":"symbol","title":"BufferedStream","url":"\/documentation\/fueledswiftconcurrency\/bufferedstream","abstract":[{"type":"text","text":"A buffered async stream that stores emitted values and replays them to new consumers."}],"kind":"symbol","navigatorTitle":[{"text":"BufferedStream","kind":"identifier"}],"type":"topic","identifier":"doc:\/\/FueledSwiftConcurrency\/documentation\/FueledSwiftConcurrency\/BufferedStream","fragments":[{"kind":"keyword","text":"class"},{"text":" ","kind":"text"},{"text":"BufferedStream","kind":"identifier"}]},"doc://FueledSwiftConcurrency/documentation/FueledSwiftConcurrency/TimeoutAsyncSequence":{"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"TimeoutAsyncSequence","kind":"identifier"}],"title":"TimeoutAsyncSequence","role":"symbol","kind":"symbol","url":"\/documentation\/fueledswiftconcurrency\/timeoutasyncsequence","abstract":[{"type":"text","text":"An async sequence that applies a timeout to another sequence."}],"identifier":"doc:\/\/FueledSwiftConcurrency\/documentation\/FueledSwiftConcurrency\/TimeoutAsyncSequence","type":"topic","navigatorTitle":[{"text":"TimeoutAsyncSequence","kind":"identifier"}]},"doc://FueledSwiftConcurrency/documentation/FueledSwiftConcurrency/AsyncCache":{"title":"AsyncCache","url":"\/documentation\/fueledswiftconcurrency\/asynccache","role":"symbol","identifier":"doc:\/\/FueledSwiftConcurrency\/documentation\/FueledSwiftConcurrency\/AsyncCache","kind":"symbol","fragments":[{"text":"actor","kind":"keyword"},{"text":" ","kind":"text"},{"text":"AsyncCache","kind":"identifier"}],"abstract":[{"text":"A concurrency-safe asynchronous cache for storing key-value pairs.","type":"text"}],"type":"topic","navigatorTitle":[{"text":"AsyncCache","kind":"identifier"}]},"doc://FueledSwiftConcurrency/documentation/FueledSwiftConcurrency/_Concurrency":{"title":"_Concurrency","role":"collection","abstract":[],"url":"\/documentation\/fueledswiftconcurrency\/_concurrency","kind":"symbol","identifier":"doc:\/\/FueledSwiftConcurrency\/documentation\/FueledSwiftConcurrency\/_Concurrency","type":"topic"},"doc://FueledSwiftConcurrency/documentation/FueledSwiftConcurrency/AsyncSemaphore":{"identifier":"doc:\/\/FueledSwiftConcurrency\/documentation\/FueledSwiftConcurrency\/AsyncSemaphore","navigatorTitle":[{"text":"AsyncSemaphore","kind":"identifier"}],"type":"topic","abstract":[{"type":"text","text":"An async-compatible counting semaphore that controls access to a resource across multiple execution contexts."}],"url":"\/documentation\/fueledswiftconcurrency\/asyncsemaphore","kind":"symbol","role":"symbol","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"AsyncSemaphore","kind":"identifier"}],"title":"AsyncSemaphore"}}}