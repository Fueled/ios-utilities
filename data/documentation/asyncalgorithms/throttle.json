{"primaryContentSections":[{"kind":"content","content":[{"type":"heading","anchor":"overview","level":2,"text":"Overview"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Author(s): "},{"type":"reference","identifier":"https:\/\/github.com\/phausler","isActive":true}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"["},{"type":"text","text":" "},{"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/AsyncThrottleSequence.swift","isActive":true},{"type":"text","text":" |"},{"type":"text","text":" "},{"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestThrottle.swift","isActive":true},{"type":"text","text":" "},{"type":"text","text":"]"}]},{"type":"heading","anchor":"Introduction","level":2,"text":"Introduction"},{"type":"paragraph","inlineContent":[{"text":"When events can potentially happen faster than the desired consumption rate, there are multiple ways to handle the situation. One approach is to emit values after a given period has elapsed. These emitted values can be reduced from the values encountered during the waiting period. This algorithm is commonly referred to as throttling.","type":"text"}]},{"type":"heading","anchor":"Proposed-Solution","level":2,"text":"Proposed Solution"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The throttle algorithm produces elements such that at least a specific interval has elapsed between them. It transacts by measuring against a specific clock. If values are produced by the base "},{"type":"codeVoice","code":"AsyncSequence"},{"text":" the throttle does not resume its next iterator until the period has elapsed or unless a terminal event is encountered.","type":"text"}]},{"inlineContent":[{"text":"The interface for this algorithm is available on all ","type":"text"},{"code":"AsyncSequence","type":"codeVoice"},{"text":" types. Unlike other algorithms like ","type":"text"},{"code":"debounce","type":"codeVoice"},{"text":", the throttle algorithm does not need to create additional tasks or require any sort of tolerance because the interval is just measured. A shorthand implementation will be offered in conjunction where the clock is the ","type":"text"},{"code":"ContinuousClock","type":"codeVoice"},{"text":", which allows for easy construction with ","type":"text"},{"code":"Duration","type":"codeVoice"},{"text":" values. An additional shorthand is offered to reduce the values such that it provides a “latest” or “earliest” value, representing the leading or trailing edge of a throttled region of production of events.","type":"text"}],"type":"paragraph"},{"code":["extension AsyncSequence {","  public func throttle<C: Clock, Reduced>(","    for interval: C.Instant.Duration, ","    clock: C, ","    reducing: @Sendable @escaping (Reduced?, Element) async -> Reduced","  ) -> AsyncThrottleSequence<Self, C, Reduced>","  ","  public func throttle<Reduced>(","    for interval: Duration, ","    reducing: @Sendable @escaping (Reduced?, Element) async -> Reduced","  ) -> AsyncThrottleSequence<Self, ContinuousClock, Reduced>","  ","  public func throttle<C: Clock>(","    for interval: C.Instant.Duration, ","    clock: C, ","    latest: Bool = true","  ) -> AsyncThrottleSequence<Self, C, Element>","  ","  public func throttle(","    for interval: Duration, ","    latest: Bool = true","  ) -> AsyncThrottleSequence<Self, ContinuousClock, Element>","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"This all boils down to a terse description of how to transform the asynchronous sequence over time."}],"type":"paragraph"},{"code":["fastEvents.throttle(for: .seconds(1))"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"In this case, the throttle transforms a potentially fast asynchronous sequence of events into one that waits for a window of 1 second to elapse before emitting a value.","type":"text"}],"type":"paragraph"},{"anchor":"Detailed-Design","level":2,"text":"Detailed Design","type":"heading"},{"inlineContent":[{"type":"text","text":"The type that implements the algorithm for throttle emits the same element type as the base that it applies to. It also throws when the base type throws (and likewise does not throw when the base type does not throw)."}],"type":"paragraph"},{"code":["public struct AsyncThrottleSequence<Base: AsyncSequence, C: Clock, Reduced> {","}","","extension AsyncThrottleSequence: AsyncSequence {","  public typealias Element = Reduced","  ","  public struct Iterator: AsyncIteratorProtocol {","    public mutating func next() async rethrows -> Reduced?","  }","  ","  public func makeAsyncIterator() -> Iterator","}","","extension AsyncThrottleSequence: Sendable ","  where Base: Sendable, Element: Sendable { }","extension AsyncThrottleSequence.Iterator: Sendable ","  where Base.AsyncIterator: Sendable { }"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"The ","type":"text"},{"code":"AsyncThrottleSequence","type":"codeVoice"},{"text":" and its ","type":"text"},{"code":"Iterator","type":"codeVoice"},{"text":" are conditionally ","type":"text"},{"code":"Sendable","type":"codeVoice"},{"text":" if the base types comprising it are ","type":"text"},{"code":"Sendable","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The time in which events are measured are from the previous emission if present. If a duration has elapsed between the last emission and the point in time the throttle is measured then that duration is counted as elapsed. The first element is considered not throttled because no interval can be constructed from the start to the first element."}],"type":"paragraph"},{"anchor":"Alternatives-Considered","level":2,"text":"Alternatives Considered","type":"heading"},{"inlineContent":[{"text":"It was considered to only provide the “latest” style APIs, however the reduction version grants more flexibility and can act as a funnel to the implementations of ","type":"text"},{"type":"codeVoice","code":"latest"},{"text":".","type":"text"}],"type":"paragraph"},{"level":2,"anchor":"CreditsInspiration","type":"heading","text":"Credits\/Inspiration"},{"inlineContent":[{"type":"text","text":"http:\/\/reactivex.io\/documentation\/operators\/sample.html"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"https:\/\/developer.apple.com\/documentation\/combine\/publishers\/throttle\/"}],"type":"paragraph"}]}],"seeAlsoSections":[{"title":"Getting Started","anchor":"Getting-Started","generated":true,"identifiers":["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AdjacentPairs","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/BufferedBytes","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chain","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Channel","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chunked","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Collections","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/CombineLatest","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Compacted","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Debounce","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Effects","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Intersperse","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Joined","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Lazy","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Merge","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Reductions"]}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Throttle"},"variants":[{"paths":["\/documentation\/asyncalgorithms\/throttle"],"traits":[{"interfaceLanguage":"swift"}]}],"hierarchy":{"paths":[["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms"]]},"kind":"article","metadata":{"title":"Throttle","modules":[{"name":"AsyncAlgorithms"}],"roleHeading":"Article","role":"article"},"sections":[],"schemaVersion":{"major":0,"patch":0,"minor":3},"references":{"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Intersperse":{"title":"Intersperse","abstract":[{"type":"text","text":"Places a given value in between each element of the asynchronous sequence."}],"url":"\/documentation\/asyncalgorithms\/intersperse","type":"topic","kind":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Intersperse","role":"article"},"https://github.com/apple/swift-async-algorithms/blob/main/Tests/AsyncAlgorithmsTests/TestThrottle.swift":{"url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestThrottle.swift","type":"link","title":"Tests","titleInlineContent":[{"type":"text","text":"Tests"}],"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestThrottle.swift"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms":{"type":"topic","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms","title":"AsyncAlgorithms","url":"\/documentation\/asyncalgorithms","kind":"symbol","abstract":[{"inlineContent":[{"type":"text","text":"Swift Async Algorithms"}],"type":"strong"},{"text":" is an open-source package of asynchronous sequence and advanced algorithms that involve concurrency, along with their related types.","type":"text"}],"role":"collection"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Effects":{"title":"Effects","abstract":[{"text":"Lists the effects of all async algorithms.","type":"text"}],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Effects","kind":"article","type":"topic","url":"\/documentation\/asyncalgorithms\/effects","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Collections":{"title":"Collection Initializers","type":"topic","url":"\/documentation\/asyncalgorithms\/collections","kind":"article","role":"article","abstract":[],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Collections"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/CombineLatest":{"title":"Combine Latest","type":"topic","url":"\/documentation\/asyncalgorithms\/combinelatest","kind":"article","role":"article","abstract":[{"type":"text","text":"Combines the latest values produced from two or more asynchronous sequences into an asynchronous sequence of tuples."}],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/CombineLatest"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/AdjacentPairs":{"title":"AdjacentPairs","type":"topic","url":"\/documentation\/asyncalgorithms\/adjacentpairs","kind":"article","role":"article","abstract":[],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AdjacentPairs"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Chain":{"title":"Chain","abstract":[{"type":"text","text":"Chains two or more asynchronous sequences together sequentially."}],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chain","type":"topic","url":"\/documentation\/asyncalgorithms\/chain","kind":"article","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Channel":{"title":"Channel","abstract":[],"url":"\/documentation\/asyncalgorithms\/channel","type":"topic","kind":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Channel","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Chunked":{"title":"Chunked","type":"topic","url":"\/documentation\/asyncalgorithms\/chunked","kind":"article","role":"article","abstract":[],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chunked"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/BufferedBytes":{"title":"AsyncBufferedByteIterator","abstract":[{"type":"text","text":"Provides a highly efficient iterator useful for iterating byte sequences derived from asynchronous read functions."}],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/BufferedBytes","type":"topic","url":"\/documentation\/asyncalgorithms\/bufferedbytes","kind":"article","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Joined":{"title":"Joined","abstract":[],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Joined","type":"topic","url":"\/documentation\/asyncalgorithms\/joined","kind":"article","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Lazy":{"title":"AsyncSyncSequence","abstract":[{"text":"This operation is available for all ","type":"text"},{"code":"Sequence","type":"codeVoice"},{"text":" types.","type":"text"}],"url":"\/documentation\/asyncalgorithms\/lazy","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Lazy","type":"topic","kind":"article","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Compacted":{"title":"Compacted","type":"topic","url":"\/documentation\/asyncalgorithms\/compacted","kind":"article","role":"article","abstract":[],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Compacted"},"https://github.com/phausler":{"type":"link","identifier":"https:\/\/github.com\/phausler","url":"https:\/\/github.com\/phausler","titleInlineContent":[{"type":"text","text":"Philippe Hausler"}],"title":"Philippe Hausler"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Debounce":{"title":"Debounce","type":"topic","url":"\/documentation\/asyncalgorithms\/debounce","kind":"article","role":"article","abstract":[],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Debounce"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Reductions":{"url":"\/documentation\/asyncalgorithms\/reductions","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Reductions","kind":"article","abstract":[],"title":"Reductions","type":"topic","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Merge":{"title":"Merge","type":"topic","url":"\/documentation\/asyncalgorithms\/merge","kind":"article","role":"article","abstract":[{"text":"Merges two or more asynchronous sequences sharing the same element type into one singular asynchronous sequence.","type":"text"}],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Merge"},"https://github.com/apple/swift-async-algorithms/blob/main/Sources/AsyncAlgorithms/AsyncThrottleSequence.swift":{"type":"link","title":"Source","titleInlineContent":[{"type":"text","text":"Source"}],"url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/AsyncThrottleSequence.swift","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/AsyncThrottleSequence.swift"}}}