{"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Collections"},"kind":"article","sections":[],"schemaVersion":{"major":0,"minor":3,"patch":0},"metadata":{"modules":[{"name":"AsyncAlgorithms"}],"title":"Collection Initializers","roleHeading":"Article","role":"article"},"variants":[{"paths":["\/documentation\/asyncalgorithms\/collections"],"traits":[{"interfaceLanguage":"swift"}]}],"hierarchy":{"paths":[["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms"]]},"primaryContentSections":[{"content":[{"type":"heading","level":2,"text":"Overview","anchor":"overview"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Author(s): "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/phausler"}],"type":"paragraph"}]}]},{"inlineContent":[{"type":"text","text":"["},{"type":"text","text":" "},{"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/Dictionary.swift","isActive":true},{"type":"text","text":","},{"type":"text","text":" "},{"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/RangeReplaceableCollection.swift","isActive":true},{"type":"text","text":","},{"type":"text","text":" "},{"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/SetAlgebra.swift","isActive":true},{"type":"text","text":" |"},{"type":"text","text":" "},{"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestDictionary.swift","isActive":true},{"type":"text","text":","},{"type":"text","text":" "},{"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestRangeReplaceableCollection.swift","isActive":true},{"type":"text","text":","},{"type":"text","text":" "},{"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestSetAlgebra.swift"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"]"}],"type":"paragraph"},{"text":"Introduction","anchor":"Introduction","type":"heading","level":2},{"inlineContent":[{"code":"Array","type":"codeVoice"},{"text":", ","type":"text"},{"code":"Dictionary","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"Set","type":"codeVoice"},{"text":" are some of the most commonly-used data structures for storing collections of elements. Having a way to transition from an ","type":"text"},{"code":"AsyncSequence","type":"codeVoice"},{"text":" to a collection is not only a useful shorthand but a powerful way of expressing direct intent for how to consume an ","type":"text"},{"code":"AsyncSequence","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"This type of functionality can be useful for examples and testing, and also for interfacing with existing APIs that expect a fully-formed collection before processing it.","type":"text"}],"type":"paragraph"},{"text":"Proposed Solution","anchor":"Proposed-Solution","type":"heading","level":2},{"inlineContent":[{"type":"text","text":"Three categories of initializers will be added to provide initializers for those three primary types: "},{"type":"codeVoice","code":"Array"},{"type":"text","text":", "},{"type":"codeVoice","code":"Dictionary"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Set"},{"type":"text","text":". However these initializers can be written in a generic fashion such that they can apply to all similar collections."}],"type":"paragraph"},{"inlineContent":[{"type":"codeVoice","code":"RangeReplaceableCollection"},{"type":"text","text":" will gain a new initializer that constructs a collection given an "},{"type":"codeVoice","code":"AsyncSequence"},{"type":"text","text":". This will allow for creating arrays from asynchronous sequences but also allow for creating types like "},{"type":"codeVoice","code":"Data"},{"type":"text","text":" or "},{"type":"codeVoice","code":"ContiguousArray"},{"type":"text","text":". Because of the nature of asynchronous sequences, this initializer must be asynchronous and declare that it rethrows errors from the base asynchronous sequence."}],"type":"paragraph"},{"syntax":"swift","code":["extension RangeReplaceableCollection {","  public init<Source: AsyncSequence>(","    _ source: Source","  ) async rethrows ","    where Source.Element == Element","}"],"type":"codeListing"},{"inlineContent":[{"type":"codeVoice","code":"Dictionary"},{"text":" will gain a family of new asynchronous, rethrowing initializers to parallel the existing ","type":"text"},{"type":"codeVoice","code":"Sequence"},{"text":"-based initializers. The initializers will be asynchronous to facilitate uniquing keys and other tasks that may be asynchronous, in addition to the asynchronous initialization of the dictionaries.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["extension Dictionary {","  public init<S: AsyncSequence>(","    uniqueKeysWithValues keysAndValues: S","  ) async rethrows ","    where S.Element == (Key, Value)","    ","  public init<S: AsyncSequence>(","    _ keysAndValues: S, ","    uniquingKeysWith combine: (Value, Value) async throws -> Value","  ) async rethrows","    where S.Element == (Key, Value)","    ","  public init<S: AsyncSequence>(","    grouping values: S, ","    by keyForValue: (S.Element) async throws -> Key","  ) async rethrows","    where Value == [S.Element]","}"],"type":"codeListing"},{"inlineContent":[{"code":"SetAlgebra","type":"codeVoice"},{"type":"text","text":" will gain a new asynchronous, rethrowing initializer that constructs a "},{"code":"SetAlgebra","type":"codeVoice"},{"type":"text","text":" type given an "},{"code":"AsyncSequence","type":"codeVoice"},{"type":"text","text":". This will allow for creating sets from asynchronous sequences and allow for creating types like "},{"code":"OptionSet","type":"codeVoice"},{"type":"text","text":" types or "},{"code":"IndexSet","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"syntax":"swift","code":["extension SetAlgebra {","  public init<Source: AsyncSequence>(","    _ source: Source","  ) async rethrows","    where Source.Element == Element","}"],"type":"codeListing"},{"level":2,"text":"Detailed Design","anchor":"Detailed-Design","type":"heading"},{"inlineContent":[{"text":"Each of the initializers is intended for uses where the ","type":"text"},{"code":"AsyncSequence","type":"codeVoice"},{"text":" being used for initialization is known to be finite. Common uses include:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Reading from files via the "},{"type":"codeVoice","code":"AsyncBytes"},{"type":"text","text":" style sequences or "},{"type":"codeVoice","code":"lines"},{"type":"text","text":" accessors."}]}]},{"content":[{"inlineContent":[{"text":"Gathering elements produced by a ","type":"text"},{"type":"codeVoice","code":"TaskGroup"},{"text":".","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Accessing a prefix of an indefinite "},{"type":"codeVoice","code":"AsyncSequence"},{"type":"text","text":"."}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"text":"Each of the initializers will use the ","type":"text"},{"code":"for","type":"codeVoice"},{"text":"-","type":"text"},{"code":"await","type":"codeVoice"},{"text":"-","type":"text"},{"code":"in","type":"codeVoice"},{"text":"\/","type":"text"},{"code":"for","type":"codeVoice"},{"text":"-","type":"text"},{"code":"try","type":"codeVoice"},{"text":"-","type":"text"},{"code":"await","type":"codeVoice"},{"text":"-","type":"text"},{"code":"in","type":"codeVoice"},{"text":" syntax to iterate the sequence directly in the initializer. In addition each initializer relies on the ","type":"text"},{"code":"AsyncSequence","type":"codeVoice"},{"text":" being passed in to properly respect cancellation. In the cases where cancellation is a potential, developers should be ready to either check immediately or be ready for initialization based on a partial sequence, depending on the behavior of the ","type":"text"},{"code":"AsyncSequence","type":"codeVoice"},{"text":" being used.","type":"text"}]},{"type":"heading","text":"RangeReplaceableCollection","level":3,"anchor":"RangeReplaceableCollection"},{"code":["let contents = try await Data(URL(fileURLWithPath: \"\/tmp\/example.bin\").resourceBytes)"],"type":"codeListing","syntax":"swift"},{"type":"heading","level":3,"text":"Dictionary","anchor":"Dictionary"},{"type":"codeListing","syntax":"swift","code":["let table = await Dictionary(uniqueKeysWithValues: zip(keys, values))"]},{"type":"heading","level":3,"text":"SetAlgebra","anchor":"SetAlgebra"},{"type":"codeListing","syntax":"swift","code":["let allItems = await Set(items.prefix(10))"]},{"anchor":"Alternatives-Considered","type":"heading","text":"Alternatives Considered","level":2},{"inlineContent":[{"text":"The spelling of these initializers could be expressed as a trailing conversion. However, that can lead to hard-to-read chains of operations. Functionally these all belong to the ","type":"text"},{"code":"reduce","type":"codeVoice"},{"text":" family of functions, but due to source readability concerns they are more ergonomic for understanding what the code does by using the initializer patterns.","type":"text"}],"type":"paragraph"},{"anchor":"CreditsInspiration","type":"heading","text":"Credits\/Inspiration","level":2},{"inlineContent":[{"type":"text","text":"The direct inspiration for each initialization is from their standard library counterparts."}],"type":"paragraph"}],"kind":"content"}],"seeAlsoSections":[{"title":"Getting Started","identifiers":["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AdjacentPairs","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/BufferedBytes","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chain","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Channel","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chunked","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/CombineLatest","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Compacted","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Debounce","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Effects","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Intersperse","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Joined","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Lazy","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Merge","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Reductions","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/RemoveDuplicates"],"generated":true,"anchor":"Getting-Started"}],"references":{"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/RemoveDuplicates":{"title":"RemoveDuplicates","abstract":[],"url":"\/documentation\/asyncalgorithms\/removeduplicates","type":"topic","kind":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/RemoveDuplicates","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Channel":{"title":"Channel","abstract":[],"url":"\/documentation\/asyncalgorithms\/channel","type":"topic","kind":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Channel","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Effects":{"title":"Effects","abstract":[{"text":"Lists the effects of all async algorithms.","type":"text"}],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Effects","kind":"article","type":"topic","url":"\/documentation\/asyncalgorithms\/effects","role":"article"},"https://github.com/apple/swift-async-algorithms/blob/main/Tests/AsyncAlgorithmsTests/TestDictionary.swift":{"title":"Tests","url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestDictionary.swift","titleInlineContent":[{"type":"text","text":"Tests"}],"type":"link","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestDictionary.swift"},"https://github.com/apple/swift-async-algorithms/blob/main/Tests/AsyncAlgorithmsTests/TestSetAlgebra.swift":{"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestSetAlgebra.swift","titleInlineContent":[{"text":"Tests","type":"text"}],"url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestSetAlgebra.swift","type":"link","title":"Tests"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Chain":{"title":"Chain","abstract":[{"type":"text","text":"Chains two or more asynchronous sequences together sequentially."}],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chain","type":"topic","url":"\/documentation\/asyncalgorithms\/chain","kind":"article","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Debounce":{"title":"Debounce","type":"topic","url":"\/documentation\/asyncalgorithms\/debounce","kind":"article","role":"article","abstract":[],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Debounce"},"https://github.com/apple/swift-async-algorithms/blob/main/Sources/AsyncAlgorithms/RangeReplaceableCollection.swift":{"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/RangeReplaceableCollection.swift","titleInlineContent":[{"type":"text","text":"Source"}],"url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/RangeReplaceableCollection.swift","type":"link","title":"Source"},"https://github.com/apple/swift-async-algorithms/blob/main/Sources/AsyncAlgorithms/SetAlgebra.swift":{"url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/SetAlgebra.swift","title":"Source","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/SetAlgebra.swift","type":"link","titleInlineContent":[{"text":"Source","type":"text"}]},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/CombineLatest":{"title":"Combine Latest","type":"topic","url":"\/documentation\/asyncalgorithms\/combinelatest","kind":"article","role":"article","abstract":[{"type":"text","text":"Combines the latest values produced from two or more asynchronous sequences into an asynchronous sequence of tuples."}],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/CombineLatest"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/AdjacentPairs":{"title":"AdjacentPairs","type":"topic","url":"\/documentation\/asyncalgorithms\/adjacentpairs","kind":"article","role":"article","abstract":[],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AdjacentPairs"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Chunked":{"title":"Chunked","type":"topic","url":"\/documentation\/asyncalgorithms\/chunked","kind":"article","role":"article","abstract":[],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chunked"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Joined":{"title":"Joined","abstract":[],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Joined","type":"topic","url":"\/documentation\/asyncalgorithms\/joined","kind":"article","role":"article"},"https://github.com/phausler":{"identifier":"https:\/\/github.com\/phausler","titleInlineContent":[{"type":"text","text":"Philippe Hausler"}],"url":"https:\/\/github.com\/phausler","type":"link","title":"Philippe Hausler"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/BufferedBytes":{"title":"AsyncBufferedByteIterator","abstract":[{"type":"text","text":"Provides a highly efficient iterator useful for iterating byte sequences derived from asynchronous read functions."}],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/BufferedBytes","type":"topic","url":"\/documentation\/asyncalgorithms\/bufferedbytes","kind":"article","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms":{"type":"topic","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms","title":"AsyncAlgorithms","url":"\/documentation\/asyncalgorithms","kind":"symbol","abstract":[{"inlineContent":[{"type":"text","text":"Swift Async Algorithms"}],"type":"strong"},{"text":" is an open-source package of asynchronous sequence and advanced algorithms that involve concurrency, along with their related types.","type":"text"}],"role":"collection"},"https://github.com/apple/swift-async-algorithms/blob/main/Tests/AsyncAlgorithmsTests/TestRangeReplaceableCollection.swift":{"url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestRangeReplaceableCollection.swift","type":"link","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestRangeReplaceableCollection.swift","titleInlineContent":[{"type":"text","text":"Tests"}],"title":"Tests"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Reductions":{"url":"\/documentation\/asyncalgorithms\/reductions","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Reductions","kind":"article","abstract":[],"title":"Reductions","type":"topic","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Lazy":{"title":"AsyncSyncSequence","abstract":[{"text":"This operation is available for all ","type":"text"},{"code":"Sequence","type":"codeVoice"},{"text":" types.","type":"text"}],"url":"\/documentation\/asyncalgorithms\/lazy","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Lazy","type":"topic","kind":"article","role":"article"},"https://github.com/apple/swift-async-algorithms/blob/main/Sources/AsyncAlgorithms/Dictionary.swift":{"type":"link","titleInlineContent":[{"type":"text","text":"Source"}],"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/Dictionary.swift","title":"Source","url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/Dictionary.swift"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Merge":{"title":"Merge","type":"topic","url":"\/documentation\/asyncalgorithms\/merge","kind":"article","role":"article","abstract":[{"text":"Merges two or more asynchronous sequences sharing the same element type into one singular asynchronous sequence.","type":"text"}],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Merge"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Intersperse":{"title":"Intersperse","abstract":[{"type":"text","text":"Places a given value in between each element of the asynchronous sequence."}],"url":"\/documentation\/asyncalgorithms\/intersperse","type":"topic","kind":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Intersperse","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Compacted":{"title":"Compacted","type":"topic","url":"\/documentation\/asyncalgorithms\/compacted","kind":"article","role":"article","abstract":[],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Compacted"}}}