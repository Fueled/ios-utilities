{"seeAlsoSections":[{"generated":true,"title":"Getting Started","identifiers":["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AdjacentPairs","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/BufferedBytes","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chain","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Channel","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chunked","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/CombineLatest","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Compacted","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Debounce","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Effects","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Intersperse","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Joined","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Lazy","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Merge","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Reductions","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/RemoveDuplicates"],"anchor":"Getting-Started"}],"schemaVersion":{"patch":0,"minor":3,"major":0},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Collections"},"metadata":{"title":"Collection Initializers","roleHeading":"Article","modules":[{"name":"AsyncAlgorithms"}],"role":"article"},"kind":"article","primaryContentSections":[{"content":[{"level":2,"type":"heading","text":"Overview","anchor":"overview"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Author(s): ","type":"text"},{"identifier":"https:\/\/github.com\/phausler","isActive":true,"type":"reference"}],"type":"paragraph"}]}]},{"inlineContent":[{"text":"[","type":"text"},{"text":" ","type":"text"},{"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/Dictionary.swift","isActive":true,"type":"reference"},{"text":",","type":"text"},{"text":" ","type":"text"},{"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/RangeReplaceableCollection.swift","isActive":true,"type":"reference"},{"text":",","type":"text"},{"text":" ","type":"text"},{"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/SetAlgebra.swift","isActive":true,"type":"reference"},{"text":" |","type":"text"},{"text":" ","type":"text"},{"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestDictionary.swift","isActive":true,"type":"reference"},{"text":",","type":"text"},{"text":" ","type":"text"},{"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestRangeReplaceableCollection.swift","isActive":true,"type":"reference"},{"text":",","type":"text"},{"text":" ","type":"text"},{"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestSetAlgebra.swift","isActive":true,"type":"reference"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"]"}],"type":"paragraph"},{"level":2,"anchor":"Introduction","text":"Introduction","type":"heading"},{"inlineContent":[{"type":"codeVoice","code":"Array"},{"type":"text","text":", "},{"type":"codeVoice","code":"Dictionary"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Set"},{"type":"text","text":" are some of the most commonly-used data structures for storing collections of elements. Having a way to transition from an "},{"type":"codeVoice","code":"AsyncSequence"},{"type":"text","text":" to a collection is not only a useful shorthand but a powerful way of expressing direct intent for how to consume an "},{"type":"codeVoice","code":"AsyncSequence"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"text":"This type of functionality can be useful for examples and testing, and also for interfacing with existing APIs that expect a fully-formed collection before processing it.","type":"text"}],"type":"paragraph"},{"level":2,"anchor":"Proposed-Solution","text":"Proposed Solution","type":"heading"},{"inlineContent":[{"text":"Three categories of initializers will be added to provide initializers for those three primary types: ","type":"text"},{"code":"Array","type":"codeVoice"},{"text":", ","type":"text"},{"code":"Dictionary","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"Set","type":"codeVoice"},{"text":". However these initializers can be written in a generic fashion such that they can apply to all similar collections.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"codeVoice","code":"RangeReplaceableCollection"},{"text":" will gain a new initializer that constructs a collection given an ","type":"text"},{"type":"codeVoice","code":"AsyncSequence"},{"text":". This will allow for creating arrays from asynchronous sequences but also allow for creating types like ","type":"text"},{"type":"codeVoice","code":"Data"},{"text":" or ","type":"text"},{"type":"codeVoice","code":"ContiguousArray"},{"text":". Because of the nature of asynchronous sequences, this initializer must be asynchronous and declare that it rethrows errors from the base asynchronous sequence.","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["extension RangeReplaceableCollection {","  public init<Source: AsyncSequence>(","    _ source: Source","  ) async rethrows ","    where Source.Element == Element","}"]},{"inlineContent":[{"type":"codeVoice","code":"Dictionary"},{"text":" will gain a family of new asynchronous, rethrowing initializers to parallel the existing ","type":"text"},{"type":"codeVoice","code":"Sequence"},{"text":"-based initializers. The initializers will be asynchronous to facilitate uniquing keys and other tasks that may be asynchronous, in addition to the asynchronous initialization of the dictionaries.","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["extension Dictionary {","  public init<S: AsyncSequence>(","    uniqueKeysWithValues keysAndValues: S","  ) async rethrows ","    where S.Element == (Key, Value)","    ","  public init<S: AsyncSequence>(","    _ keysAndValues: S, ","    uniquingKeysWith combine: (Value, Value) async throws -> Value","  ) async rethrows","    where S.Element == (Key, Value)","    ","  public init<S: AsyncSequence>(","    grouping values: S, ","    by keyForValue: (S.Element) async throws -> Key","  ) async rethrows","    where Value == [S.Element]","}"]},{"inlineContent":[{"type":"codeVoice","code":"SetAlgebra"},{"type":"text","text":" will gain a new asynchronous, rethrowing initializer that constructs a "},{"type":"codeVoice","code":"SetAlgebra"},{"type":"text","text":" type given an "},{"type":"codeVoice","code":"AsyncSequence"},{"type":"text","text":". This will allow for creating sets from asynchronous sequences and allow for creating types like "},{"type":"codeVoice","code":"OptionSet"},{"type":"text","text":" types or "},{"type":"codeVoice","code":"IndexSet"},{"type":"text","text":"."}],"type":"paragraph"},{"code":["extension SetAlgebra {","  public init<Source: AsyncSequence>(","    _ source: Source","  ) async rethrows","    where Source.Element == Element","}"],"type":"codeListing","syntax":"swift"},{"level":2,"text":"Detailed Design","type":"heading","anchor":"Detailed-Design"},{"inlineContent":[{"text":"Each of the initializers is intended for uses where the ","type":"text"},{"type":"codeVoice","code":"AsyncSequence"},{"type":"text","text":" being used for initialization is known to be finite. Common uses include:"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Reading from files via the "},{"code":"AsyncBytes","type":"codeVoice"},{"type":"text","text":" style sequences or "},{"code":"lines","type":"codeVoice"},{"type":"text","text":" accessors."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Gathering elements produced by a "},{"type":"codeVoice","code":"TaskGroup"},{"type":"text","text":"."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Accessing a prefix of an indefinite ","type":"text"},{"code":"AsyncSequence","type":"codeVoice"},{"type":"text","text":"."}]}]}],"type":"unorderedList"},{"inlineContent":[{"text":"Each of the initializers will use the ","type":"text"},{"code":"for","type":"codeVoice"},{"text":"-","type":"text"},{"code":"await","type":"codeVoice"},{"type":"text","text":"-"},{"code":"in","type":"codeVoice"},{"type":"text","text":"\/"},{"code":"for","type":"codeVoice"},{"type":"text","text":"-"},{"type":"codeVoice","code":"try"},{"text":"-","type":"text"},{"type":"codeVoice","code":"await"},{"text":"-","type":"text"},{"code":"in","type":"codeVoice"},{"text":" syntax to iterate the sequence directly in the initializer. In addition each initializer relies on the ","type":"text"},{"code":"AsyncSequence","type":"codeVoice"},{"text":" being passed in to properly respect cancellation. In the cases where cancellation is a potential, developers should be ready to either check immediately or be ready for initialization based on a partial sequence, depending on the behavior of the ","type":"text"},{"code":"AsyncSequence","type":"codeVoice"},{"type":"text","text":" being used."}],"type":"paragraph"},{"anchor":"RangeReplaceableCollection","level":3,"type":"heading","text":"RangeReplaceableCollection"},{"syntax":"swift","type":"codeListing","code":["let contents = try await Data(URL(fileURLWithPath: \"\/tmp\/example.bin\").resourceBytes)"]},{"anchor":"Dictionary","level":3,"type":"heading","text":"Dictionary"},{"syntax":"swift","type":"codeListing","code":["let table = await Dictionary(uniqueKeysWithValues: zip(keys, values))"]},{"anchor":"SetAlgebra","level":3,"type":"heading","text":"SetAlgebra"},{"syntax":"swift","type":"codeListing","code":["let allItems = await Set(items.prefix(10))"]},{"anchor":"Alternatives-Considered","level":2,"type":"heading","text":"Alternatives Considered"},{"inlineContent":[{"text":"The spelling of these initializers could be expressed as a trailing conversion. However, that can lead to hard-to-read chains of operations. Functionally these all belong to the ","type":"text"},{"code":"reduce","type":"codeVoice"},{"text":" family of functions, but due to source readability concerns they are more ergonomic for understanding what the code does by using the initializer patterns.","type":"text"}],"type":"paragraph"},{"anchor":"CreditsInspiration","level":2,"type":"heading","text":"Credits\/Inspiration"},{"inlineContent":[{"type":"text","text":"The direct inspiration for each initialization is from their standard library counterparts."}],"type":"paragraph"}],"kind":"content"}],"hierarchy":{"paths":[["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms"]]},"sections":[],"variants":[{"paths":["\/documentation\/asyncalgorithms\/collections"],"traits":[{"interfaceLanguage":"swift"}]}],"references":{"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Compacted":{"title":"Compacted","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Compacted","kind":"article","url":"\/documentation\/asyncalgorithms\/compacted","role":"article","type":"topic","abstract":[]},"https://github.com/apple/swift-async-algorithms/blob/main/Sources/AsyncAlgorithms/RangeReplaceableCollection.swift":{"url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/RangeReplaceableCollection.swift","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/RangeReplaceableCollection.swift","titleInlineContent":[{"text":"Source","type":"text"}],"type":"link","title":"Source"},"https://github.com/apple/swift-async-algorithms/blob/main/Sources/AsyncAlgorithms/SetAlgebra.swift":{"title":"Source","titleInlineContent":[{"type":"text","text":"Source"}],"url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/SetAlgebra.swift","type":"link","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/SetAlgebra.swift"},"https://github.com/apple/swift-async-algorithms/blob/main/Tests/AsyncAlgorithmsTests/TestDictionary.swift":{"titleInlineContent":[{"type":"text","text":"Tests"}],"url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestDictionary.swift","title":"Tests","type":"link","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestDictionary.swift"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Channel":{"url":"\/documentation\/asyncalgorithms\/channel","type":"topic","title":"Channel","abstract":[],"kind":"article","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Channel"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/CombineLatest":{"title":"Combine Latest","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/CombineLatest","kind":"article","url":"\/documentation\/asyncalgorithms\/combinelatest","role":"article","type":"topic","abstract":[{"type":"text","text":"Combines the latest values produced from two or more asynchronous sequences into an asynchronous sequence of tuples."}]},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Chunked":{"title":"Chunked","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chunked","kind":"article","url":"\/documentation\/asyncalgorithms\/chunked","role":"article","type":"topic","abstract":[]},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Lazy":{"title":"AsyncSyncSequence","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Lazy","kind":"article","url":"\/documentation\/asyncalgorithms\/lazy","role":"article","type":"topic","abstract":[{"type":"text","text":"This operation is available for all "},{"type":"codeVoice","code":"Sequence"},{"type":"text","text":" types."}]},"https://github.com/apple/swift-async-algorithms/blob/main/Tests/AsyncAlgorithmsTests/TestRangeReplaceableCollection.swift":{"url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestRangeReplaceableCollection.swift","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestRangeReplaceableCollection.swift","titleInlineContent":[{"text":"Tests","type":"text"}],"type":"link","title":"Tests"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Merge":{"role":"article","abstract":[{"text":"Merges two or more asynchronous sequences sharing the same element type into one singular asynchronous sequence.","type":"text"}],"type":"topic","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Merge","url":"\/documentation\/asyncalgorithms\/merge","kind":"article","title":"Merge"},"https://github.com/phausler":{"title":"Philippe Hausler","titleInlineContent":[{"type":"text","text":"Philippe Hausler"}],"url":"https:\/\/github.com\/phausler","type":"link","identifier":"https:\/\/github.com\/phausler"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Intersperse":{"title":"Intersperse","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Intersperse","kind":"article","url":"\/documentation\/asyncalgorithms\/intersperse","role":"article","type":"topic","abstract":[{"type":"text","text":"Places a given value in between each element of the asynchronous sequence."}]},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Reductions":{"title":"Reductions","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Reductions","kind":"article","url":"\/documentation\/asyncalgorithms\/reductions","role":"article","type":"topic","abstract":[]},"https://github.com/apple/swift-async-algorithms/blob/main/Sources/AsyncAlgorithms/Dictionary.swift":{"titleInlineContent":[{"type":"text","text":"Source"}],"url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/Dictionary.swift","title":"Source","type":"link","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/Dictionary.swift"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/BufferedBytes":{"title":"AsyncBufferedByteIterator","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/BufferedBytes","kind":"article","url":"\/documentation\/asyncalgorithms\/bufferedbytes","role":"article","type":"topic","abstract":[{"type":"text","text":"Provides a highly efficient iterator useful for iterating byte sequences derived from asynchronous read functions."}]},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Chain":{"url":"\/documentation\/asyncalgorithms\/chain","type":"topic","title":"Chain","abstract":[{"text":"Chains two or more asynchronous sequences together sequentially.","type":"text"}],"kind":"article","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chain"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/RemoveDuplicates":{"url":"\/documentation\/asyncalgorithms\/removeduplicates","type":"topic","title":"RemoveDuplicates","abstract":[],"kind":"article","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/RemoveDuplicates"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms":{"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms","kind":"symbol","role":"collection","url":"\/documentation\/asyncalgorithms","title":"AsyncAlgorithms","abstract":[{"type":"strong","inlineContent":[{"text":"Swift Async Algorithms","type":"text"}]},{"type":"text","text":" is an open-source package of asynchronous sequence and advanced algorithms that involve concurrency, along with their related types."}],"type":"topic"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Effects":{"url":"\/documentation\/asyncalgorithms\/effects","type":"topic","title":"Effects","abstract":[{"text":"Lists the effects of all async algorithms.","type":"text"}],"kind":"article","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Effects"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/AdjacentPairs":{"url":"\/documentation\/asyncalgorithms\/adjacentpairs","type":"topic","title":"AdjacentPairs","abstract":[],"kind":"article","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AdjacentPairs"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Joined":{"title":"Joined","url":"\/documentation\/asyncalgorithms\/joined","type":"topic","abstract":[],"kind":"article","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Joined"},"https://github.com/apple/swift-async-algorithms/blob/main/Tests/AsyncAlgorithmsTests/TestSetAlgebra.swift":{"title":"Tests","titleInlineContent":[{"type":"text","text":"Tests"}],"url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestSetAlgebra.swift","type":"link","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestSetAlgebra.swift"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Debounce":{"title":"Debounce","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Debounce","kind":"article","url":"\/documentation\/asyncalgorithms\/debounce","role":"article","type":"topic","abstract":[]}}}