{"seeAlsoSections":[{"generated":true,"title":"Getting Started","identifiers":["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AdjacentPairs","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/BufferedBytes","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chain","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Channel","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chunked","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/CombineLatest","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Compacted","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Debounce","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Effects","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Intersperse","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Joined","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Lazy","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Merge","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Reductions","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/RemoveDuplicates"],"anchor":"Getting-Started"}],"primaryContentSections":[{"kind":"content","content":[{"text":"Overview","anchor":"overview","type":"heading","level":2},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Author(s): "},{"type":"reference","identifier":"https:\/\/github.com\/phausler","isActive":true}]}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"["},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/Dictionary.swift"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/RangeReplaceableCollection.swift"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/SetAlgebra.swift"},{"type":"text","text":" |"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestDictionary.swift"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestRangeReplaceableCollection.swift"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestSetAlgebra.swift"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"]"}],"type":"paragraph"},{"text":"Introduction","anchor":"Introduction","type":"heading","level":2},{"inlineContent":[{"code":"Array","type":"codeVoice"},{"type":"text","text":", "},{"code":"Dictionary","type":"codeVoice"},{"type":"text","text":" and "},{"code":"Set","type":"codeVoice"},{"type":"text","text":" are some of the most commonly-used data structures for storing collections of elements. Having a way to transition from an "},{"code":"AsyncSequence","type":"codeVoice"},{"type":"text","text":" to a collection is not only a useful shorthand but a powerful way of expressing direct intent for how to consume an "},{"code":"AsyncSequence","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"This type of functionality can be useful for examples and testing, and also for interfacing with existing APIs that expect a fully-formed collection before processing it."}],"type":"paragraph"},{"text":"Proposed Solution","anchor":"Proposed-Solution","type":"heading","level":2},{"inlineContent":[{"type":"text","text":"Three categories of initializers will be added to provide initializers for those three primary types: "},{"code":"Array","type":"codeVoice"},{"type":"text","text":", "},{"code":"Dictionary","type":"codeVoice"},{"type":"text","text":" and "},{"code":"Set","type":"codeVoice"},{"type":"text","text":". However these initializers can be written in a generic fashion such that they can apply to all similar collections."}],"type":"paragraph"},{"inlineContent":[{"code":"RangeReplaceableCollection","type":"codeVoice"},{"type":"text","text":" will gain a new initializer that constructs a collection given an "},{"code":"AsyncSequence","type":"codeVoice"},{"type":"text","text":". This will allow for creating arrays from asynchronous sequences but also allow for creating types like "},{"code":"Data","type":"codeVoice"},{"type":"text","text":" or "},{"code":"ContiguousArray","type":"codeVoice"},{"type":"text","text":". Because of the nature of asynchronous sequences, this initializer must be asynchronous and declare that it rethrows errors from the base asynchronous sequence."}],"type":"paragraph"},{"syntax":"swift","code":["extension RangeReplaceableCollection {","  public init<Source: AsyncSequence>(","    _ source: Source","  ) async rethrows ","    where Source.Element == Element","}"],"type":"codeListing"},{"inlineContent":[{"code":"Dictionary","type":"codeVoice"},{"type":"text","text":" will gain a family of new asynchronous, rethrowing initializers to parallel the existing "},{"code":"Sequence","type":"codeVoice"},{"type":"text","text":"-based initializers. The initializers will be asynchronous to facilitate uniquing keys and other tasks that may be asynchronous, in addition to the asynchronous initialization of the dictionaries."}],"type":"paragraph"},{"syntax":"swift","code":["extension Dictionary {","  public init<S: AsyncSequence>(","    uniqueKeysWithValues keysAndValues: S","  ) async rethrows ","    where S.Element == (Key, Value)","    ","  public init<S: AsyncSequence>(","    _ keysAndValues: S, ","    uniquingKeysWith combine: (Value, Value) async throws -> Value","  ) async rethrows","    where S.Element == (Key, Value)","    ","  public init<S: AsyncSequence>(","    grouping values: S, ","    by keyForValue: (S.Element) async throws -> Key","  ) async rethrows","    where Value == [S.Element]","}"],"type":"codeListing"},{"inlineContent":[{"code":"SetAlgebra","type":"codeVoice"},{"type":"text","text":" will gain a new asynchronous, rethrowing initializer that constructs a "},{"code":"SetAlgebra","type":"codeVoice"},{"type":"text","text":" type given an "},{"code":"AsyncSequence","type":"codeVoice"},{"type":"text","text":". This will allow for creating sets from asynchronous sequences and allow for creating types like "},{"code":"OptionSet","type":"codeVoice"},{"type":"text","text":" types or "},{"code":"IndexSet","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"syntax":"swift","code":["extension SetAlgebra {","  public init<Source: AsyncSequence>(","    _ source: Source","  ) async rethrows","    where Source.Element == Element","}"],"type":"codeListing"},{"text":"Detailed Design","anchor":"Detailed-Design","type":"heading","level":2},{"inlineContent":[{"type":"text","text":"Each of the initializers is intended for uses where the "},{"type":"codeVoice","code":"AsyncSequence"},{"type":"text","text":" being used for initialization is known to be finite. Common uses include:"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Reading from files via the "},{"type":"codeVoice","code":"AsyncBytes"},{"type":"text","text":" style sequences or "},{"type":"codeVoice","code":"lines"},{"type":"text","text":" accessors."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Gathering elements produced by a "},{"type":"codeVoice","code":"TaskGroup"},{"type":"text","text":"."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Accessing a prefix of an indefinite "},{"type":"codeVoice","code":"AsyncSequence"},{"type":"text","text":"."}],"type":"paragraph"}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"Each of the initializers will use the "},{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"type":"codeVoice","code":"await"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"type":"text","text":"\/"},{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"type":"codeVoice","code":"try"},{"type":"text","text":"-"},{"type":"codeVoice","code":"await"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"type":"text","text":" syntax to iterate the sequence directly in the initializer. In addition each initializer relies on the "},{"type":"codeVoice","code":"AsyncSequence"},{"type":"text","text":" being passed in to properly respect cancellation. In the cases where cancellation is a potential, developers should be ready to either check immediately or be ready for initialization based on a partial sequence, depending on the behavior of the "},{"type":"codeVoice","code":"AsyncSequence"},{"type":"text","text":" being used."}],"type":"paragraph"},{"text":"RangeReplaceableCollection","anchor":"RangeReplaceableCollection","type":"heading","level":3},{"syntax":"swift","code":["let contents = try await Data(URL(fileURLWithPath: \"\/tmp\/example.bin\").resourceBytes)"],"type":"codeListing"},{"text":"Dictionary","anchor":"Dictionary","type":"heading","level":3},{"syntax":"swift","code":["let table = await Dictionary(uniqueKeysWithValues: zip(keys, values))"],"type":"codeListing"},{"text":"SetAlgebra","anchor":"SetAlgebra","type":"heading","level":3},{"syntax":"swift","code":["let allItems = await Set(items.prefix(10))"],"type":"codeListing"},{"type":"heading","anchor":"Alternatives-Considered","text":"Alternatives Considered","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"The spelling of these initializers could be expressed as a trailing conversion. However, that can lead to hard-to-read chains of operations. Functionally these all belong to the "},{"code":"reduce","type":"codeVoice"},{"text":" family of functions, but due to source readability concerns they are more ergonomic for understanding what the code does by using the initializer patterns.","type":"text"}]},{"type":"heading","anchor":"CreditsInspiration","text":"Credits\/Inspiration","level":2},{"type":"paragraph","inlineContent":[{"text":"The direct inspiration for each initialization is from their standard library counterparts.","type":"text"}]}]}],"sections":[],"kind":"article","schemaVersion":{"minor":3,"patch":0,"major":0},"identifier":{"url":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Collections","interfaceLanguage":"swift"},"hierarchy":{"paths":[["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms"]]},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/asyncalgorithms\/collections"]}],"metadata":{"title":"Collection Initializers","role":"article","roleHeading":"Article","modules":[{"name":"AsyncAlgorithms"}]},"references":{"https://github.com/apple/swift-async-algorithms/blob/main/Sources/AsyncAlgorithms/SetAlgebra.swift":{"title":"Source","titleInlineContent":[{"type":"text","text":"Source"}],"url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/SetAlgebra.swift","type":"link","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/SetAlgebra.swift"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Intersperse":{"title":"Intersperse","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Intersperse","url":"\/documentation\/asyncalgorithms\/intersperse","abstract":[{"type":"text","text":"Places a given value in between each element of the asynchronous sequence."}],"kind":"article"},"https://github.com/apple/swift-async-algorithms/blob/main/Tests/AsyncAlgorithmsTests/TestRangeReplaceableCollection.swift":{"title":"Tests","titleInlineContent":[{"type":"text","text":"Tests"}],"url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestRangeReplaceableCollection.swift","type":"link","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestRangeReplaceableCollection.swift"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Debounce":{"title":"Debounce","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Debounce","url":"\/documentation\/asyncalgorithms\/debounce","abstract":[],"kind":"article"},"https://github.com/apple/swift-async-algorithms/blob/main/Tests/AsyncAlgorithmsTests/TestDictionary.swift":{"title":"Tests","titleInlineContent":[{"type":"text","text":"Tests"}],"url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestDictionary.swift","type":"link","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestDictionary.swift"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/RemoveDuplicates":{"title":"RemoveDuplicates","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/RemoveDuplicates","url":"\/documentation\/asyncalgorithms\/removeduplicates","abstract":[],"kind":"article"},"https://github.com/apple/swift-async-algorithms/blob/main/Tests/AsyncAlgorithmsTests/TestSetAlgebra.swift":{"title":"Tests","titleInlineContent":[{"type":"text","text":"Tests"}],"url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestSetAlgebra.swift","type":"link","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestSetAlgebra.swift"},"https://github.com/apple/swift-async-algorithms/blob/main/Sources/AsyncAlgorithms/Dictionary.swift":{"title":"Source","titleInlineContent":[{"type":"text","text":"Source"}],"url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/Dictionary.swift","type":"link","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/Dictionary.swift"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Chunked":{"title":"Chunked","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chunked","url":"\/documentation\/asyncalgorithms\/chunked","abstract":[],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/BufferedBytes":{"title":"AsyncBufferedByteIterator","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/BufferedBytes","url":"\/documentation\/asyncalgorithms\/bufferedbytes","abstract":[{"type":"text","text":"Provides a highly efficient iterator useful for iterating byte sequences derived from asynchronous read functions."}],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Chain":{"title":"Chain","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chain","url":"\/documentation\/asyncalgorithms\/chain","abstract":[{"type":"text","text":"Chains two or more asynchronous sequences together sequentially."}],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/AdjacentPairs":{"title":"AdjacentPairs","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AdjacentPairs","url":"\/documentation\/asyncalgorithms\/adjacentpairs","abstract":[],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Reductions":{"title":"Reductions","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Reductions","url":"\/documentation\/asyncalgorithms\/reductions","abstract":[],"kind":"article"},"https://github.com/apple/swift-async-algorithms/blob/main/Sources/AsyncAlgorithms/RangeReplaceableCollection.swift":{"url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/RangeReplaceableCollection.swift","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/RangeReplaceableCollection.swift","type":"link","titleInlineContent":[{"type":"text","text":"Source"}],"title":"Source"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Joined":{"title":"Joined","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Joined","url":"\/documentation\/asyncalgorithms\/joined","abstract":[],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Effects":{"title":"Effects","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Effects","url":"\/documentation\/asyncalgorithms\/effects","abstract":[{"type":"text","text":"Lists the effects of all async algorithms."}],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Compacted":{"title":"Compacted","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Compacted","url":"\/documentation\/asyncalgorithms\/compacted","abstract":[],"kind":"article"},"https://github.com/phausler":{"url":"https:\/\/github.com\/phausler","identifier":"https:\/\/github.com\/phausler","type":"link","titleInlineContent":[{"type":"text","text":"Philippe Hausler"}],"title":"Philippe Hausler"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/CombineLatest":{"title":"Combine Latest","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/CombineLatest","url":"\/documentation\/asyncalgorithms\/combinelatest","abstract":[{"type":"text","text":"Combines the latest values produced from two or more asynchronous sequences into an asynchronous sequence of tuples."}],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Lazy":{"title":"AsyncSyncSequence","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Lazy","url":"\/documentation\/asyncalgorithms\/lazy","abstract":[{"type":"text","text":"This operation is available for all "},{"code":"Sequence","type":"codeVoice"},{"type":"text","text":" types."}],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Channel":{"title":"Channel","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Channel","url":"\/documentation\/asyncalgorithms\/channel","abstract":[],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Merge":{"title":"Merge","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Merge","url":"\/documentation\/asyncalgorithms\/merge","abstract":[{"type":"text","text":"Merges two or more asynchronous sequences sharing the same element type into one singular asynchronous sequence."}],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms":{"type":"topic","abstract":[{"type":"strong","inlineContent":[{"type":"text","text":"Swift Async Algorithms"}]},{"type":"text","text":" is an open-source package of asynchronous sequence and advanced algorithms that involve concurrency, along with their related types."}],"title":"AsyncAlgorithms","kind":"symbol","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms","role":"collection","url":"\/documentation\/asyncalgorithms"}}}