{"abstract":[{"type":"text","text":"A channel for sending elements from one task to another with back pressure."}],"schemaVersion":{"minor":3,"major":0,"patch":0},"kind":"symbol","metadata":{"roleHeading":"Class","externalID":"s:15AsyncAlgorithms0A7ChannelC","role":"symbol","title":"AsyncChannel","modules":[{"name":"AsyncAlgorithms"}],"platforms":[{"name":"iOS","introducedAt":"13.0","beta":false,"deprecated":false,"unavailable":false},{"name":"macOS","introducedAt":"10.15","beta":false,"deprecated":false,"unavailable":false},{"name":"tvOS","introducedAt":"13.0","beta":false,"deprecated":false,"unavailable":false},{"name":"watchOS","introducedAt":"6.0","beta":false,"deprecated":false,"unavailable":false}],"symbolKind":"class","navigatorTitle":[{"kind":"identifier","text":"AsyncChannel"}],"fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"AsyncChannel"}]},"hierarchy":{"paths":[["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms"]]},"relationshipsSections":[{"kind":"relationships","identifiers":["doc:\/\/AsyncAlgorithms\/s8SendableP","doc:\/\/AsyncAlgorithms\/s16SendableMetatypeP","doc:\/\/AsyncAlgorithms\/Sci"],"type":"conformsTo","title":"Conforms To"}],"variants":[{"paths":["\/documentation\/asyncalgorithms\/asyncchannel"],"traits":[{"interfaceLanguage":"swift"}]}],"primaryContentSections":[{"kind":"declarations","declarations":[{"tokens":[{"kind":"keyword","text":"final"},{"kind":"text","text":" "},{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"AsyncChannel"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"Element"},{"kind":"text","text":"> "},{"kind":"keyword","text":"where"},{"kind":"text","text":" "},{"kind":"typeIdentifier","text":"Element"},{"kind":"text","text":" : "},{"kind":"typeIdentifier","text":"Sendable","preciseIdentifier":"s:s8SendableP"}],"platforms":["macOS"],"languages":["swift"]}]},{"kind":"content","content":[{"type":"heading","level":2,"text":"Overview","anchor":"overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"AsyncChannel"},{"type":"text","text":" class is intended to be used as a communication type between tasks,"},{"type":"text","text":" "},{"type":"text","text":"particularly when one task produces values and another task consumes those values. The back"},{"type":"text","text":" "},{"type":"text","text":"pressure applied by "},{"type":"codeVoice","code":"send(_:)"},{"type":"text","text":" via the suspension\/resume ensures that"},{"type":"text","text":" "},{"type":"text","text":"the production of values does not exceed the consumption of values from iteration. This method"},{"type":"text","text":" "},{"type":"text","text":"suspends after enqueuing the event and is resumed when the next call to "},{"type":"codeVoice","code":"next()"},{"type":"text","text":" "},{"type":"text","text":"on the "},{"type":"codeVoice","code":"Iterator"},{"type":"text","text":" is made, or when "},{"type":"codeVoice","code":"finish()"},{"type":"text","text":" is called from another Task."},{"type":"text","text":" "},{"type":"text","text":"As "},{"code":"finish()","type":"codeVoice"},{"text":" induces a terminal state, there is no more need for a back pressure management.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"This function does not suspend and will finish all the pending iterations."}]}]}],"sections":[],"topicSections":[{"identifiers":["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AsyncChannel\/Iterator"],"title":"Structures","generated":true,"anchor":"Structures"},{"identifiers":["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AsyncChannel\/init()"],"title":"Initializers","generated":true,"anchor":"Initializers"},{"identifiers":["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AsyncChannel\/finish()","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AsyncChannel\/makeAsyncIterator()","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AsyncChannel\/send(_:)"],"title":"Instance Methods","generated":true,"anchor":"Instance-Methods"},{"identifiers":["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AsyncChannel\/AsyncIterator","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AsyncChannel\/Element"],"title":"Type Aliases","generated":true,"anchor":"Type-Aliases"},{"identifiers":["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AsyncChannel\/AsyncSequence-Implementations","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AsyncChannel\/AsyncSequence-Implementations"],"title":"Default Implementations","generated":true,"anchor":"Default-Implementations"}],"identifier":{"url":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AsyncChannel","interfaceLanguage":"swift"},"references":{"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/AsyncChannel/finish()":{"abstract":[{"type":"text","text":"Immediately resumes all the suspended operations."},{"type":"text","text":" "},{"type":"text","text":"All subsequent calls to "},{"type":"codeVoice","code":"next(_:)"},{"type":"text","text":" will resume immediately."}],"type":"topic","title":"finish()","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AsyncChannel\/finish()","url":"\/documentation\/asyncalgorithms\/asyncchannel\/finish()","role":"symbol","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"finish"},{"kind":"text","text":"()"}],"kind":"symbol"},"doc://AsyncAlgorithms/s16SendableMetatypeP":{"type":"unresolvable","identifier":"doc:\/\/AsyncAlgorithms\/s16SendableMetatypeP","title":"Swift.SendableMetatype"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms":{"type":"topic","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms","title":"AsyncAlgorithms","url":"\/documentation\/asyncalgorithms","kind":"symbol","abstract":[{"inlineContent":[{"type":"text","text":"Swift Async Algorithms"}],"type":"strong"},{"text":" is an open-source package of asynchronous sequence and advanced algorithms that involve concurrency, along with their related types.","type":"text"}],"role":"collection"},"doc://AsyncAlgorithms/s8SendableP":{"title":"Swift.Sendable","identifier":"doc:\/\/AsyncAlgorithms\/s8SendableP","type":"unresolvable"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/AsyncChannel/Iterator":{"navigatorTitle":[{"text":"Iterator","kind":"identifier"}],"type":"topic","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AsyncChannel\/Iterator","title":"AsyncChannel.Iterator","url":"\/documentation\/asyncalgorithms\/asyncchannel\/iterator","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Iterator","kind":"identifier"}],"kind":"symbol","abstract":[],"role":"symbol"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/AsyncChannel/Element":{"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AsyncChannel\/Element","type":"topic","url":"\/documentation\/asyncalgorithms\/asyncchannel\/element","abstract":[],"title":"AsyncChannel.Element","fragments":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"kind":"identifier","text":"Element"}],"navigatorTitle":[{"kind":"identifier","text":"Element"}],"role":"symbol","kind":"symbol"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/AsyncChannel":{"url":"\/documentation\/asyncalgorithms\/asyncchannel","title":"AsyncChannel","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"AsyncChannel","kind":"identifier"}],"abstract":[{"text":"A channel for sending elements from one task to another with back pressure.","type":"text"}],"navigatorTitle":[{"text":"AsyncChannel","kind":"identifier"}],"kind":"symbol","type":"topic","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AsyncChannel","role":"symbol"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/AsyncChannel/AsyncIterator":{"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AsyncChannel\/AsyncIterator","type":"topic","url":"\/documentation\/asyncalgorithms\/asyncchannel\/asynciterator","abstract":[],"title":"AsyncChannel.AsyncIterator","fragments":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"kind":"identifier","text":"AsyncIterator"}],"navigatorTitle":[{"kind":"identifier","text":"AsyncIterator"}],"role":"symbol","kind":"symbol"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/AsyncChannel/AsyncSequence-Implementations":{"type":"topic","url":"\/documentation\/asyncalgorithms\/asyncchannel\/asyncsequence-implementations","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AsyncChannel\/AsyncSequence-Implementations","kind":"article","abstract":[],"title":"AsyncSequence Implementations","role":"collectionGroup"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/AsyncChannel/init()":{"abstract":[],"type":"topic","url":"\/documentation\/asyncalgorithms\/asyncchannel\/init()","title":"init()","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AsyncChannel\/init()","role":"symbol","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"()"}],"kind":"symbol"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/AsyncChannel/send(_:)":{"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AsyncChannel\/send(_:)","type":"topic","url":"\/documentation\/asyncalgorithms\/asyncchannel\/send(_:)","abstract":[{"text":"Sends an element to an awaiting iteration. This function will resume when the next call to ","type":"text"},{"code":"next()","type":"codeVoice"},{"text":" is made","type":"text"},{"text":" ","type":"text"},{"text":"or when a call to ","type":"text"},{"code":"finish()","type":"codeVoice"},{"text":" is made from another task.","type":"text"},{"text":" ","type":"text"},{"text":"If the channel is already finished then this returns immediately.","type":"text"},{"text":" ","type":"text"},{"text":"If the task is cancelled, this function will resume without sending the element.","type":"text"},{"text":" ","type":"text"},{"text":"Other sending operations from other tasks will remain active.","type":"text"}],"title":"send(_:)","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"send","kind":"identifier"},{"text":"(","kind":"text"},{"text":"Element","kind":"typeIdentifier"},{"text":") ","kind":"text"},{"text":"async","kind":"keyword"}],"role":"symbol","kind":"symbol"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/AsyncChannel/makeAsyncIterator()":{"abstract":[],"type":"topic","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AsyncChannel\/makeAsyncIterator()","url":"\/documentation\/asyncalgorithms\/asyncchannel\/makeasynciterator()","title":"makeAsyncIterator()","role":"symbol","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"makeAsyncIterator"},{"kind":"text","text":"() -> "},{"kind":"typeIdentifier","preciseIdentifier":"s:15AsyncAlgorithms0A7ChannelC","text":"AsyncChannel"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"Element"},{"kind":"text","text":">."},{"kind":"typeIdentifier","preciseIdentifier":"s:15AsyncAlgorithms0A7ChannelC8IteratorV","text":"Iterator"}],"kind":"symbol"},"doc://AsyncAlgorithms/Sci":{"title":"_Concurrency.AsyncSequence","type":"unresolvable","identifier":"doc:\/\/AsyncAlgorithms\/Sci"}}}