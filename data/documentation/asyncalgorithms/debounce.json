{"identifier":{"url":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Debounce","interfaceLanguage":"swift"},"metadata":{"modules":[{"name":"AsyncAlgorithms"}],"title":"Debounce","roleHeading":"Article","role":"article"},"seeAlsoSections":[{"title":"Getting Started","identifiers":["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AdjacentPairs","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/BufferedBytes","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chain","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Channel","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chunked","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Collections","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/CombineLatest","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Compacted","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Effects","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Intersperse","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Joined","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Lazy","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Merge","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Reductions","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/RemoveDuplicates"],"anchor":"Getting-Started","generated":true}],"schemaVersion":{"patch":0,"major":0,"minor":3},"primaryContentSections":[{"content":[{"text":"Overview","anchor":"overview","type":"heading","level":2},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Author(s): ","type":"text"},{"identifier":"https:\/\/github.com\/phausler","type":"reference","isActive":true}]}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"type":"text","text":"["},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/Debounce\/AsyncDebounceSequence.swift"},{"type":"text","text":" |"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestDebounce.swift"},{"type":"text","text":" "},{"type":"text","text":"]"}]},{"text":"Introduction","anchor":"Introduction","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"When events can potentially happen faster than the desired consumption rate, there are multiple ways to handle the situation. One approach is to only emit values after a given period of time of inactivity, or “quiescence”, has elapsed. This algorithm is commonly referred to as debouncing."}]},{"text":"Proposed Solution","anchor":"Proposed-Solution","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"The debounce algorithm produces elements after a particular duration has passed between events. It transacts within a given tolerance applied to a clock. If values are produced by the base "},{"type":"codeVoice","code":"AsyncSequence"},{"type":"text","text":" during this quiet period, the debounce does not resume its next iterator until the period has elapsed with no values are produced or unless a terminal event is encountered."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The interface for this algorithm is available on all "},{"type":"codeVoice","code":"AsyncSequence"},{"type":"text","text":" types where the base type, iterator, and element are "},{"type":"codeVoice","code":"Sendable"},{"type":"text","text":", since this algorithm will inherently create tasks to manage their timing of events. A shorthand implementation will be offered where the clock is the "},{"type":"codeVoice","code":"ContinuousClock"},{"type":"text","text":", which allows for easy construction with "},{"type":"codeVoice","code":"Duration"},{"type":"text","text":" values."}]},{"syntax":"swift","type":"codeListing","code":["extension AsyncSequence {","  public func debounce<C: Clock>(","    for interval: C.Instant.Duration, ","    tolerance: C.Instant.Duration? = nil, ","    clock: C","  ) -> AsyncDebounceSequence<Self, C>","  ","  public func debounce(","    for interval: Duration, ","    tolerance: Duration? = nil","  ) -> AsyncDebounceSequence<Self, ContinuousClock>","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This all boils down to a terse description of how to transform the asynchronous sequence over time."}]},{"syntax":"swift","type":"codeListing","code":["fastEvents.debounce(for: .seconds(1))"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this case it transforms a potentially fast asynchronous sequence of events into one that waits for a window of 1 second with no events to elapse before emitting a value."}]},{"text":"Detailed Design","anchor":"Detailed-Design","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"The type that implements the algorithm for debounce emits the same element type as the base that it applies to. It also throws when the base type throws (and likewise does not throw when the base type does not throw)."}]},{"syntax":"swift","type":"codeListing","code":["public struct AsyncDebounceSequence<Base: AsyncSequence, C: Clock>: Sendable","  where Base.AsyncIterator: Sendable, Base.Element: Sendable, Base: Sendable {","}","","extension AsyncDebounceSequence: AsyncSequence {","  public typealias Element = Base.Element","  ","  public struct Iterator: AsyncIteratorProtocol, Sendable {","    public mutating func next() async rethrows -> Base.Element? ","  }","  ","  public func makeAsyncIterator() -> Iterator","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Since the stored types comprising "},{"type":"codeVoice","code":"AsyncDebounceSequence"},{"type":"text","text":" must be "},{"type":"codeVoice","code":"Sendable"},{"type":"text","text":"; "},{"type":"codeVoice","code":"AsyncDebounceSequence"},{"type":"text","text":" is unconditionally always "},{"type":"codeVoice","code":"Sendable"},{"type":"text","text":"."}]},{"text":"Alternatives Considered","anchor":"Alternatives-Considered","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"An alternative form of "},{"type":"codeVoice","code":"debounce"},{"type":"text","text":" could exist similar to the reductions of "},{"type":"codeVoice","code":"throttle"},{"type":"text","text":", where a closure would be invoked for each value being set as the latest, and reducing a new value to produce for the debounce."}]},{"text":"Credits\/Inspiration","anchor":"CreditsInspiration","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"The naming for debounce comes as a term of art; originally this term was inspired by electronic circuitry. When a physical switch closes a circuit it can easily have a “bouncing” behavior (also called chatter) that is caused by electrical contact resistance and the physical bounce of springs associated with switches. That phenomenon is often addressed with additional circuits to de-bounce (removing the bouncing) by ensuring a certain quiescence occurs."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"http:\/\/reactivex.io\/documentation\/operators\/debounce.html"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"https:\/\/developer.apple.com\/documentation\/combine\/publishers\/debounce\/"}]}],"kind":"content"}],"variants":[{"paths":["\/documentation\/asyncalgorithms\/debounce"],"traits":[{"interfaceLanguage":"swift"}]}],"sections":[],"kind":"article","hierarchy":{"paths":[["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms"]]},"references":{"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/CombineLatest":{"title":"Combine Latest","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/CombineLatest","url":"\/documentation\/asyncalgorithms\/combinelatest","abstract":[{"type":"text","text":"Combines the latest values produced from two or more asynchronous sequences into an asynchronous sequence of tuples."}],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Channel":{"title":"Channel","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Channel","url":"\/documentation\/asyncalgorithms\/channel","abstract":[],"kind":"article"},"https://github.com/phausler":{"identifier":"https:\/\/github.com\/phausler","title":"Philippe Hausler","titleInlineContent":[{"text":"Philippe Hausler","type":"text"}],"url":"https:\/\/github.com\/phausler","type":"link"},"https://github.com/apple/swift-async-algorithms/blob/main/Tests/AsyncAlgorithmsTests/TestDebounce.swift":{"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestDebounce.swift","title":"Tests","titleInlineContent":[{"text":"Tests","type":"text"}],"url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestDebounce.swift","type":"link"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/BufferedBytes":{"title":"AsyncBufferedByteIterator","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/BufferedBytes","url":"\/documentation\/asyncalgorithms\/bufferedbytes","abstract":[{"type":"text","text":"Provides a highly efficient iterator useful for iterating byte sequences derived from asynchronous read functions."}],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms":{"type":"topic","abstract":[{"type":"strong","inlineContent":[{"type":"text","text":"Swift Async Algorithms"}]},{"type":"text","text":" is an open-source package of asynchronous sequence and advanced algorithms that involve concurrency, along with their related types."}],"title":"AsyncAlgorithms","kind":"symbol","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms","role":"collection","url":"\/documentation\/asyncalgorithms"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Compacted":{"title":"Compacted","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Compacted","url":"\/documentation\/asyncalgorithms\/compacted","abstract":[],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Chunked":{"title":"Chunked","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chunked","url":"\/documentation\/asyncalgorithms\/chunked","abstract":[],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Merge":{"title":"Merge","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Merge","url":"\/documentation\/asyncalgorithms\/merge","abstract":[{"type":"text","text":"Merges two or more asynchronous sequences sharing the same element type into one singular asynchronous sequence."}],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Intersperse":{"title":"Intersperse","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Intersperse","url":"\/documentation\/asyncalgorithms\/intersperse","abstract":[{"type":"text","text":"Places a given value in between each element of the asynchronous sequence."}],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/RemoveDuplicates":{"title":"RemoveDuplicates","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/RemoveDuplicates","url":"\/documentation\/asyncalgorithms\/removeduplicates","abstract":[],"kind":"article"},"https://github.com/apple/swift-async-algorithms/blob/main/Sources/AsyncAlgorithms/Debounce/AsyncDebounceSequence.swift":{"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/Debounce\/AsyncDebounceSequence.swift","title":"Source","titleInlineContent":[{"text":"Source","type":"text"}],"url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/Debounce\/AsyncDebounceSequence.swift","type":"link"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/AdjacentPairs":{"title":"AdjacentPairs","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AdjacentPairs","url":"\/documentation\/asyncalgorithms\/adjacentpairs","abstract":[],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Chain":{"title":"Chain","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chain","url":"\/documentation\/asyncalgorithms\/chain","abstract":[{"type":"text","text":"Chains two or more asynchronous sequences together sequentially."}],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Effects":{"title":"Effects","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Effects","url":"\/documentation\/asyncalgorithms\/effects","abstract":[{"type":"text","text":"Lists the effects of all async algorithms."}],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Lazy":{"title":"AsyncSyncSequence","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Lazy","url":"\/documentation\/asyncalgorithms\/lazy","abstract":[{"type":"text","text":"This operation is available for all "},{"code":"Sequence","type":"codeVoice"},{"type":"text","text":" types."}],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Reductions":{"title":"Reductions","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Reductions","url":"\/documentation\/asyncalgorithms\/reductions","abstract":[],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Joined":{"title":"Joined","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Joined","url":"\/documentation\/asyncalgorithms\/joined","abstract":[],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Collections":{"title":"Collection Initializers","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Collections","url":"\/documentation\/asyncalgorithms\/collections","abstract":[],"kind":"article"}}}