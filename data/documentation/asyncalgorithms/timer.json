{"primaryContentSections":[{"kind":"content","content":[{"text":"Overview","type":"heading","anchor":"overview","level":2},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Author(s): ","type":"text"},{"isActive":true,"identifier":"https:\/\/github.com\/phausler","type":"reference"}]}]}]},{"inlineContent":[{"text":"[","type":"text"},{"text":" ","type":"text"},{"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/AsyncTimerSequence.swift"},{"text":" |","type":"text"},{"text":" ","type":"text"},{"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestTimer.swift"},{"text":" ","type":"text"},{"text":"]","type":"text"}],"type":"paragraph"},{"text":"Introduction","type":"heading","anchor":"Introduction","level":2},{"inlineContent":[{"text":"Producing elements at regular intervals can be useful for composing with other algorithms. These can range from invoking code at specific times to using those regular intervals as a delimiter of events. There are other cases this exists in APIs however those do not currently interact with Swift concurrency. These existing APIs are ones like ","type":"text"},{"type":"codeVoice","code":"Timer"},{"text":" or ","type":"text"},{"type":"codeVoice","code":"DispatchTimer"},{"text":" but are bound to internal clocks that are not extensible.","type":"text"}],"type":"paragraph"},{"text":"Proposed Solution","type":"heading","anchor":"Proposed-Solution","level":2},{"inlineContent":[{"type":"text","text":"We propose to add a new type; "},{"type":"codeVoice","code":"AsyncTimerSequence"},{"type":"text","text":" which utilizes the new "},{"code":"Clock","type":"codeVoice"},{"text":", ","type":"text"},{"code":"Instant","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"Duration","type":"codeVoice"},{"text":" types. This allows the interaction of the timer to custom implementations of types adopting ","type":"text"},{"code":"Clock","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This asynchronous sequence will produce elements of the clockâ€™s "},{"type":"codeVoice","code":"Instant"},{"type":"text","text":" type after the interval has elapsed. That instant will be the "},{"type":"codeVoice","code":"now"},{"type":"text","text":" at the time that the sleep has resumed. For each invocation to "},{"type":"codeVoice","code":"next()"},{"type":"text","text":" the "},{"type":"codeVoice","code":"AsyncTimerSequence.Iterator"},{"type":"text","text":" will calculate the next deadline to resume and pass that and the tolerance to the clock. If at any point in time the task executing that iteration is cancelled the iteration will return "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" from the call to "},{"type":"codeVoice","code":"next()"},{"type":"text","text":"."}]},{"type":"codeListing","code":["public struct AsyncTimerSequence<C: Clock>: AsyncSequence {","  public typealias Element = C.Instant","  ","  public struct Iterator: AsyncIteratorProtocol {","    public mutating func next() async -> C.Instant?","  }","  ","  public init(","    interval: C.Instant.Duration, ","    tolerance: C.Instant.Duration? = nil, ","    clock: C","  )","  ","  public func makeAsyncIterator() -> Iterator","}","","extension AsyncTimerSequence where C == SuspendingClock {","  public static func repeating(every interval: Duration, tolerance: Duration? = nil) -> AsyncTimerSequence<SuspendingClock>","}","","extension AsyncTimerSequence: Sendable { }","extension AsyncTimerSequence.Iterator: Sendable { }"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Since all the types comprising "},{"type":"codeVoice","code":"AsyncTimerSequence"},{"type":"text","text":" are "},{"type":"codeVoice","code":"Sendable"},{"type":"text","text":" these types are also "},{"type":"codeVoice","code":"Sendable"},{"type":"text","text":"."}]},{"level":2,"text":"Credits\/Inspiration","type":"heading","anchor":"CreditsInspiration"},{"type":"paragraph","inlineContent":[{"text":"https:\/\/developer.apple.com\/documentation\/foundation\/timer","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"https:\/\/developer.apple.com\/documentation\/foundation\/timer\/timerpublisher"}]}]}],"seeAlsoSections":[{"title":"Getting Started","anchor":"Getting-Started","generated":true,"identifiers":["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AdjacentPairs","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/BufferedBytes","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chain","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Channel","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chunked","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Collections","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/CombineLatest","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Compacted","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Debounce","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Effects","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Intersperse","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Joined","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Lazy","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Merge","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Reductions"]}],"identifier":{"url":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Timer","interfaceLanguage":"swift"},"variants":[{"paths":["\/documentation\/asyncalgorithms\/timer"],"traits":[{"interfaceLanguage":"swift"}]}],"hierarchy":{"paths":[["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms"]]},"kind":"article","sections":[],"metadata":{"title":"Timer","roleHeading":"Article","role":"article","modules":[{"name":"AsyncAlgorithms"}]},"schemaVersion":{"major":0,"minor":3,"patch":0},"references":{"https://github.com/apple/swift-async-algorithms/blob/main/Tests/AsyncAlgorithmsTests/TestTimer.swift":{"type":"link","title":"Tests","titleInlineContent":[{"text":"Tests","type":"text"}],"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestTimer.swift","url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestTimer.swift"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Channel":{"title":"Channel","abstract":[],"url":"\/documentation\/asyncalgorithms\/channel","type":"topic","kind":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Channel","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Compacted":{"title":"Compacted","type":"topic","url":"\/documentation\/asyncalgorithms\/compacted","kind":"article","role":"article","abstract":[],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Compacted"},"https://github.com/phausler":{"titleInlineContent":[{"text":"Philippe Hausler","type":"text"}],"identifier":"https:\/\/github.com\/phausler","url":"https:\/\/github.com\/phausler","title":"Philippe Hausler","type":"link"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Intersperse":{"title":"Intersperse","abstract":[{"type":"text","text":"Places a given value in between each element of the asynchronous sequence."}],"url":"\/documentation\/asyncalgorithms\/intersperse","type":"topic","kind":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Intersperse","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/AdjacentPairs":{"title":"AdjacentPairs","type":"topic","url":"\/documentation\/asyncalgorithms\/adjacentpairs","kind":"article","role":"article","abstract":[],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AdjacentPairs"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Merge":{"title":"Merge","type":"topic","url":"\/documentation\/asyncalgorithms\/merge","kind":"article","role":"article","abstract":[{"text":"Merges two or more asynchronous sequences sharing the same element type into one singular asynchronous sequence.","type":"text"}],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Merge"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Joined":{"title":"Joined","abstract":[],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Joined","type":"topic","url":"\/documentation\/asyncalgorithms\/joined","kind":"article","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Lazy":{"title":"AsyncSyncSequence","abstract":[{"text":"This operation is available for all ","type":"text"},{"code":"Sequence","type":"codeVoice"},{"text":" types.","type":"text"}],"url":"\/documentation\/asyncalgorithms\/lazy","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Lazy","type":"topic","kind":"article","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/CombineLatest":{"title":"Combine Latest","type":"topic","url":"\/documentation\/asyncalgorithms\/combinelatest","kind":"article","role":"article","abstract":[{"type":"text","text":"Combines the latest values produced from two or more asynchronous sequences into an asynchronous sequence of tuples."}],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/CombineLatest"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Debounce":{"title":"Debounce","type":"topic","url":"\/documentation\/asyncalgorithms\/debounce","kind":"article","role":"article","abstract":[],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Debounce"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms":{"type":"topic","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms","title":"AsyncAlgorithms","url":"\/documentation\/asyncalgorithms","kind":"symbol","abstract":[{"inlineContent":[{"type":"text","text":"Swift Async Algorithms"}],"type":"strong"},{"text":" is an open-source package of asynchronous sequence and advanced algorithms that involve concurrency, along with their related types.","type":"text"}],"role":"collection"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Chunked":{"title":"Chunked","type":"topic","url":"\/documentation\/asyncalgorithms\/chunked","kind":"article","role":"article","abstract":[],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chunked"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Reductions":{"url":"\/documentation\/asyncalgorithms\/reductions","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Reductions","kind":"article","abstract":[],"title":"Reductions","type":"topic","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Chain":{"title":"Chain","abstract":[{"type":"text","text":"Chains two or more asynchronous sequences together sequentially."}],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chain","type":"topic","url":"\/documentation\/asyncalgorithms\/chain","kind":"article","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Effects":{"title":"Effects","abstract":[{"text":"Lists the effects of all async algorithms.","type":"text"}],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Effects","kind":"article","type":"topic","url":"\/documentation\/asyncalgorithms\/effects","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/BufferedBytes":{"title":"AsyncBufferedByteIterator","abstract":[{"type":"text","text":"Provides a highly efficient iterator useful for iterating byte sequences derived from asynchronous read functions."}],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/BufferedBytes","type":"topic","url":"\/documentation\/asyncalgorithms\/bufferedbytes","kind":"article","role":"article"},"https://github.com/apple/swift-async-algorithms/blob/main/Sources/AsyncAlgorithms/AsyncTimerSequence.swift":{"title":"Source","url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/AsyncTimerSequence.swift","type":"link","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/AsyncTimerSequence.swift","titleInlineContent":[{"type":"text","text":"Source"}]},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Collections":{"title":"Collection Initializers","type":"topic","url":"\/documentation\/asyncalgorithms\/collections","kind":"article","role":"article","abstract":[],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Collections"}}}