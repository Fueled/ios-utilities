{"metadata":{"role":"article","title":"Channel","modules":[{"name":"AsyncAlgorithms"}],"roleHeading":"Article"},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Channel"},"seeAlsoSections":[{"title":"Getting Started","generated":true,"identifiers":["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AdjacentPairs","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/BufferedBytes","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chain","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chunked","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Collections","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/CombineLatest","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Compacted","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Debounce","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Effects","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Intersperse","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Joined","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Lazy","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Merge","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Reductions","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/RemoveDuplicates"],"anchor":"Getting-Started"}],"hierarchy":{"paths":[["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms"]]},"kind":"article","primaryContentSections":[{"content":[{"type":"heading","level":2,"anchor":"overview","text":"Overview"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Author(s): "},{"isActive":true,"identifier":"https:\/\/github.com\/phausler","type":"reference"}]}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"type":"text","text":"["},{"text":" ","type":"text"},{"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/Channels\/AsyncChannel.swift","isActive":true},{"text":",","type":"text"},{"type":"text","text":" "},{"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/Channels\/AsyncThrowingChannel.swift","isActive":true,"type":"reference"},{"type":"text","text":" |"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestChannel.swift"},{"text":" ","type":"text"},{"text":"]","type":"text"}]},{"anchor":"Introduction","text":"Introduction","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"AsyncStream"},{"type":"text","text":" introduced a mechanism to send buffered elements from a context that doesn’t use Swift concurrency into one that does. That design only addressed a portion of the potential use cases; the missing portion was the back pressure excerpted across two concurrency domains."}]},{"anchor":"Proposed-Solution","type":"heading","text":"Proposed Solution","level":2},{"inlineContent":[{"text":"To achieve a system that supports back pressure and allows for the communication of more than one value from one task to another we are introducing a new type, the ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"channel"}]},{"type":"text","text":". The channel will be a reference-type asynchronous sequence with an asynchronous sending capability that awaits the consumption of iteration. Each value sent by the channel will await the consumption of that value by iteration. That awaiting behavior will allow for the affordance of back pressure applied from the consumption site to be transmitted to the production site. This means that the rate of production cannot exceed the rate of consumption, and that the rate of consumption cannot exceed the rate of production. Sending a terminal event to the channel will instantly resume all pending operations for every producers and consumers."}],"type":"paragraph"},{"level":2,"type":"heading","text":"Detailed Design","anchor":"Detailed-Design"},{"inlineContent":[{"type":"text","text":"Similar to the "},{"code":"AsyncStream","type":"codeVoice"},{"type":"text","text":" and "},{"code":"AsyncThrowingStream","type":"codeVoice"},{"type":"text","text":" types, the type for sending elements via back pressure will come in two versions. These two versions will account for the throwing nature or non-throwing nature of the elements being produced."}],"type":"paragraph"},{"inlineContent":[{"text":"Each type will have functions to send elements and to send terminal events.","type":"text"}],"type":"paragraph"},{"code":["public final class AsyncChannel<Element: Sendable>: AsyncSequence, Sendable {","  public struct Iterator: AsyncIteratorProtocol, Sendable {","    public mutating func next() async -> Element?","  }","  ","  public init(element elementType: Element.Type = Element.self)","  ","  public func send(_ element: Element) async","  public func finish()","  ","  public func makeAsyncIterator() -> Iterator","}","","public final class AsyncThrowingChannel<Element: Sendable, Failure: Error>: AsyncSequence, Sendable {","  public struct Iterator: AsyncIteratorProtocol, Sendable {","    public mutating func next() async throws -> Element?","  }","  ","  public init(element elementType: Element.Type = Element.self, failure failureType: Failure.Type = Failure.self)","  ","  public func send(_ element: Element) async","  public func fail(_ error: Error) where Failure == Error","  public func finish()","  ","  public func makeAsyncIterator() -> Iterator","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"Channels are intended to be used as communication types between tasks. Particularly when one task produces values and another task consumes said values. On the one hand, the back pressure applied by ","type":"text"},{"type":"codeVoice","code":"send(_:)"},{"text":" via the suspension\/resume ensures that the production of values does not exceed the consumption of values from iteration. This method suspends after enqueuing the event and is resumed when the next call to ","type":"text"},{"code":"next()","type":"codeVoice"},{"text":" on the ","type":"text"},{"type":"codeVoice","code":"Iterator"},{"type":"text","text":" is made. On the other hand, the call to "},{"type":"codeVoice","code":"finish()"},{"type":"text","text":" or "},{"type":"codeVoice","code":"fail(_:)"},{"type":"text","text":" immediately resumes all the pending operations for every producers and consumers. Thus, every suspended "},{"type":"codeVoice","code":"send(_:)"},{"text":" operations instantly resume, so as every suspended ","type":"text"},{"code":"next()","type":"codeVoice"},{"text":" operations by producing a nil value, or by throwing an error, indicating the termination of the iterations. Further calls to ","type":"text"},{"code":"send(_:)","type":"codeVoice"},{"text":" will immediately resume. The calls to ","type":"text"},{"type":"codeVoice","code":"send(:)"},{"type":"text","text":" and "},{"code":"next()","type":"codeVoice"},{"text":" will immediately resume when their supporting task is cancelled, other operations from other tasks will remain active.","type":"text"}]},{"code":["let channel = AsyncChannel<String>()","Task {","  while let resultOfLongCalculation = doLongCalculations() {","    await channel.send(resultOfLongCalculation)","  }","  channel.finish()","}","","for await calculationResult in channel {","  print(calculationResult)","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"The example above uses a task to perform intense calculations; each of which are sent to the other task via the "},{"type":"codeVoice","code":"send(_:)"},{"type":"text","text":" method. That call to "},{"type":"codeVoice","code":"send(_:)"},{"type":"text","text":" returns when the next iteration of the channel is invoked."}],"type":"paragraph"},{"anchor":"Alternatives-Considered","text":"Alternatives Considered","type":"heading","level":2},{"inlineContent":[{"type":"text","text":"The use of the name “subject” was considered, due to its heritage as a name for a sync-to-async adapter type."}],"type":"paragraph"},{"inlineContent":[{"text":"It was considered to make ","type":"text"},{"code":"AsyncChannel","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"AsyncThrowingChannel","type":"codeVoice"},{"text":" actors, however due to the cancellation internals it would imply that these types would need to create new tasks to handle cancel events. The advantages of an actor in this particular case did not outweigh the impact of adjusting the implementations to be actors.","type":"text"}],"type":"paragraph"},{"anchor":"CreditsInspiration","text":"Credits\/Inspiration","type":"heading","level":2},{"inlineContent":[{"type":"codeVoice","code":"AsyncChannel"},{"type":"text","text":" and "},{"type":"codeVoice","code":"AsyncThrowingChannel"},{"type":"text","text":" was heavily inspired from "},{"type":"codeVoice","code":"Subject"},{"type":"text","text":" but with the key difference that it uses Swift concurrency to apply back pressure."}],"type":"paragraph"},{"inlineContent":[{"text":"https:\/\/developer.apple.com\/documentation\/combine\/subject\/","type":"text"}],"type":"paragraph"}],"kind":"content"}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/asyncalgorithms\/channel"]}],"sections":[],"schemaVersion":{"minor":3,"major":0,"patch":0},"references":{"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Merge":{"title":"Merge","type":"topic","url":"\/documentation\/asyncalgorithms\/merge","kind":"article","role":"article","abstract":[{"text":"Merges two or more asynchronous sequences sharing the same element type into one singular asynchronous sequence.","type":"text"}],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Merge"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Joined":{"title":"Joined","abstract":[],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Joined","type":"topic","url":"\/documentation\/asyncalgorithms\/joined","kind":"article","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Effects":{"title":"Effects","abstract":[{"text":"Lists the effects of all async algorithms.","type":"text"}],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Effects","kind":"article","type":"topic","url":"\/documentation\/asyncalgorithms\/effects","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Chain":{"title":"Chain","abstract":[{"type":"text","text":"Chains two or more asynchronous sequences together sequentially."}],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chain","type":"topic","url":"\/documentation\/asyncalgorithms\/chain","kind":"article","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms":{"type":"topic","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms","title":"AsyncAlgorithms","url":"\/documentation\/asyncalgorithms","kind":"symbol","abstract":[{"inlineContent":[{"type":"text","text":"Swift Async Algorithms"}],"type":"strong"},{"text":" is an open-source package of asynchronous sequence and advanced algorithms that involve concurrency, along with their related types.","type":"text"}],"role":"collection"},"https://github.com/apple/swift-async-algorithms/blob/main/Sources/AsyncAlgorithms/Channels/AsyncChannel.swift":{"url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/Channels\/AsyncChannel.swift","type":"link","title":"Source","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/Channels\/AsyncChannel.swift","titleInlineContent":[{"text":"Source","type":"text"}]},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Compacted":{"title":"Compacted","type":"topic","url":"\/documentation\/asyncalgorithms\/compacted","kind":"article","role":"article","abstract":[],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Compacted"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Debounce":{"title":"Debounce","type":"topic","url":"\/documentation\/asyncalgorithms\/debounce","kind":"article","role":"article","abstract":[],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Debounce"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Chunked":{"title":"Chunked","type":"topic","url":"\/documentation\/asyncalgorithms\/chunked","kind":"article","role":"article","abstract":[],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chunked"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Collections":{"title":"Collection Initializers","type":"topic","url":"\/documentation\/asyncalgorithms\/collections","kind":"article","role":"article","abstract":[],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Collections"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/BufferedBytes":{"title":"AsyncBufferedByteIterator","abstract":[{"type":"text","text":"Provides a highly efficient iterator useful for iterating byte sequences derived from asynchronous read functions."}],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/BufferedBytes","type":"topic","url":"\/documentation\/asyncalgorithms\/bufferedbytes","kind":"article","role":"article"},"https://github.com/phausler":{"title":"Philippe Hausler","titleInlineContent":[{"type":"text","text":"Philippe Hausler"}],"type":"link","url":"https:\/\/github.com\/phausler","identifier":"https:\/\/github.com\/phausler"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/CombineLatest":{"title":"Combine Latest","type":"topic","url":"\/documentation\/asyncalgorithms\/combinelatest","kind":"article","role":"article","abstract":[{"type":"text","text":"Combines the latest values produced from two or more asynchronous sequences into an asynchronous sequence of tuples."}],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/CombineLatest"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Reductions":{"url":"\/documentation\/asyncalgorithms\/reductions","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Reductions","kind":"article","abstract":[],"title":"Reductions","type":"topic","role":"article"},"https://github.com/apple/swift-async-algorithms/blob/main/Sources/AsyncAlgorithms/Channels/AsyncThrowingChannel.swift":{"url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/Channels\/AsyncThrowingChannel.swift","type":"link","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/Channels\/AsyncThrowingChannel.swift","titleInlineContent":[{"text":"Source","type":"text"}],"title":"Source"},"https://github.com/apple/swift-async-algorithms/blob/main/Tests/AsyncAlgorithmsTests/TestChannel.swift":{"titleInlineContent":[{"text":"Tests","type":"text"}],"title":"Tests","type":"link","url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestChannel.swift","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestChannel.swift"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/AdjacentPairs":{"title":"AdjacentPairs","type":"topic","url":"\/documentation\/asyncalgorithms\/adjacentpairs","kind":"article","role":"article","abstract":[],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AdjacentPairs"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Intersperse":{"title":"Intersperse","abstract":[{"type":"text","text":"Places a given value in between each element of the asynchronous sequence."}],"url":"\/documentation\/asyncalgorithms\/intersperse","type":"topic","kind":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Intersperse","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/RemoveDuplicates":{"title":"RemoveDuplicates","abstract":[],"url":"\/documentation\/asyncalgorithms\/removeduplicates","type":"topic","kind":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/RemoveDuplicates","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Lazy":{"title":"AsyncSyncSequence","abstract":[{"text":"This operation is available for all ","type":"text"},{"code":"Sequence","type":"codeVoice"},{"text":" types.","type":"text"}],"url":"\/documentation\/asyncalgorithms\/lazy","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Lazy","type":"topic","kind":"article","role":"article"}}}