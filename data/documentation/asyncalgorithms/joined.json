{"hierarchy":{"paths":[["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms"]]},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/asyncalgorithms\/joined"]}],"metadata":{"role":"article","roleHeading":"Article","modules":[{"name":"AsyncAlgorithms"}],"title":"Joined"},"sections":[],"seeAlsoSections":[{"title":"Getting Started","identifiers":["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AdjacentPairs","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/BufferedBytes","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chain","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Channel","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chunked","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Collections","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/CombineLatest","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Compacted","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Debounce","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Effects","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Intersperse","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Lazy","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Merge","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Reductions","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/RemoveDuplicates"],"generated":true,"anchor":"Getting-Started"}],"identifier":{"url":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Joined","interfaceLanguage":"swift"},"primaryContentSections":[{"kind":"content","content":[{"anchor":"overview","level":2,"type":"heading","text":"Overview"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Author(s): "},{"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/kperryua"}]}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"text":"[","type":"text"},{"text":" ","type":"text"},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/AsyncJoinedSequence.swift"},{"type":"text","text":" |"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestJoin.swift"},{"type":"text","text":" "},{"type":"text","text":"]"}]},{"text":"Introduction","type":"heading","anchor":"Introduction","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"Concatenates an asynchronous sequence of asynchronous sequences that share an "},{"type":"codeVoice","code":"Element"},{"type":"text","text":" type together sequentially where the elements from the resulting asynchronous sequence are comprised in order from the elements of the first asynchronous sequence and then the second (and so on) or until an error occurs. Similar to "},{"type":"codeVoice","code":"chain()"},{"type":"text","text":", except the number of asynchronous sequences to concatenate is not known up front."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Optionally allows inserting the elements of a separator asynchronous sequence in between each of the other sequences."}]},{"syntax":"swift","type":"codeListing","code":["let sequenceOfURLs: AsyncSequence<URL> = ...","let sequenceOfLines = sequenceOfURLs.map { $0.lines }","let joinedWithSeparator = sequenceOfLines.joined(separator: [\"====================\"].async)","","for try await lineOrSeparator in joinedWithSeparator {","  print(lineOrSeparator)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This example shows how an "},{"type":"codeVoice","code":"AsyncSequence"},{"type":"text","text":" of "},{"type":"codeVoice","code":"URL"},{"type":"text","text":"s can be turned into an "},{"type":"codeVoice","code":"AsyncSequence"},{"type":"text","text":" of the lines of each of those files in sequence, with a separator line in between each file."}]},{"anchor":"Proposed-Solution","level":2,"type":"heading","text":"Proposed Solution"},{"syntax":"swift","type":"codeListing","code":["extension AsyncSequence where Element: AsyncSequence {","  public func joined() -> AsyncJoinedSequence<Self> {","    return AsyncJoinedSequence(self)","  }","}"]},{"syntax":"swift","type":"codeListing","code":["extension AsyncSequence where Element: AsyncSequence {","  public func joined<Separator: AsyncSequence>(separator: Separator) -> AsyncJoinedBySeparatorSequence<Self, Separator> {","    return AsyncJoinedBySeparatorSequence(self, separator: separator)","  }","}"]},{"anchor":"Detailed-Design","level":2,"type":"heading","text":"Detailed Design"},{"syntax":"swift","type":"codeListing","code":["public struct AsyncJoinedSequence<Base: AsyncSequence>: AsyncSequence where Base.Element: AsyncSequence {","  public typealias Element = Base.Element.Element","","  public struct Iterator: AsyncIteratorProtocol {","    public mutating func next() async rethrows -> Base.Element.Element?","  }","  ","  public func makeAsyncIterator() -> Iterator","}","","extension AsyncJoinedSequence: Sendable","  where","    Base: Sendable,","    Base.Element: Sendable,","    Base.Element.Element: Sendable,","    Base.AsyncIterator: Sendable,","    Base.Element.AsyncIterator: Sendable { }","    ","extension AsyncJoinedSequence.Iterator: Sendable","  where","    Base: Sendable,","    Base.Element: Sendable,","    Base.Element.Element: Sendable,","    Base.AsyncIterator: Sendable,","    Base.Element.AsyncIterator: Sendable { }"]},{"syntax":"swift","type":"codeListing","code":["public struct AsyncJoinedBySeparatorSequence<Base: AsyncSequence, Separator: AsyncSequence>: AsyncSequence ","  where Base.Element: AsyncSequence, Separator.Element == Base.Element.Element {","  public typealias Element = Base.Element.Element","","  public struct Iterator: AsyncIteratorProtocol {","    public mutating func next() async rethrows -> Base.Element.Element?","  }","","  public func makeAsyncIterator() -> Iterator","}","","extension AsyncJoinedBySeparatorSequence: Sendable","  where ","    Base: Sendable, ","    Base.Element: Sendable, ","    Base.Element.Element: Sendable, ","    Base.AsyncIterator: Sendable, ","    Separator: Sendable, ","    Separator.AsyncIterator: Sendable, ","    Base.Element.AsyncIterator: Sendable { }","    ","extension AsyncJoinedBySeparatorSequence.Iterator: Sendable","  where ","    Base: Sendable, ","    Base.Element: Sendable, ","    Base.Element.Element: Sendable, ","    Base.AsyncIterator: Sendable, ","    Separator: Sendable, ","    Separator.AsyncIterator: Sendable, ","    Base.Element.AsyncIterator: Sendable { }"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The resulting "},{"type":"codeVoice","code":"AsyncJoinedSequence"},{"type":"text","text":" or "},{"type":"codeVoice","code":"AsyncJoinedBySeparatorSequence"},{"type":"text","text":" type is an asynchronous sequence, with conditional conformance to "},{"code":"Sendable","type":"codeVoice"},{"type":"text","text":" when the arguments conform."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When any of the asynchronous sequences being joined together come to their end of iteration, the "},{"type":"codeVoice","code":"Joined"},{"type":"text","text":" sequence iteration proceeds to the separator asynchronous sequence, if any. When the separator asynchronous sequence terminates, or if no separator was specified, it proceeds on to the next asynchronous sequence. When the last asynchronous sequence reaches the end of iteration the "},{"type":"codeVoice","code":"AsyncJoinedSequence"},{"type":"text","text":" or "},{"code":"AsyncJoinedBySeparatorSequence","type":"codeVoice"},{"text":" then ends its iteration. At any point in time if one of the comprising asynchronous sequences ever throws an error during iteration the ","type":"text"},{"code":"AsyncJoinedSequence","type":"codeVoice"},{"text":" or ","type":"text"},{"code":"AsyncJoinedBySeparatorSequence","type":"codeVoice"},{"text":" iteration will throw that error and end iteration.","type":"text"}]},{"anchor":"Future-Directions","level":2,"type":"heading","text":"Future Directions"},{"type":"paragraph","inlineContent":[{"text":"The Swift Algorithms package has ","type":"text"},{"isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-algorithms\/blob\/main\/Guides\/Joined.md","type":"reference"},{"type":"text","text":". It is conceivable to bring asynchronous variants of those over to "},{"type":"codeVoice","code":"AsyncSequence"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The variant that takes a single element as a separator is straightforward, but can be trivially replicated with "},{"type":"codeVoice","code":"[element].async"},{"text":". However, it may be beneficial for performance to reimplement this directly.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"There is another variant that takes a closure that allows one to customize the separator based on the return value of a closure. That closure is passed each of the two consecutive asynchronous sequences (not the two neighboring elements in consecutive sequences). This variant arguably has the greatest utility when the sequence type conforms to "},{"type":"codeVoice","code":"Collection"},{"type":"text","text":", allowing either the "},{"type":"codeVoice","code":"count"},{"type":"text","text":" or any arbitrary element to be obtained directly. With "},{"type":"codeVoice","code":"AsyncSequence"},{"type":"text","text":", it is less likely that this function with provide a similar level of utility, so it has been omitted."}]},{"type":"heading","level":2,"anchor":"Alternatives-Considered","text":"Alternatives Considered"},{"inlineContent":[{"text":"Because ","type":"text"},{"code":"joined()","type":"codeVoice"},{"text":" is essentially identical to ","type":"text"},{"code":"flatMap { $0 }","type":"codeVoice"},{"text":", it was considered that this should be called ","type":"text"},{"type":"codeVoice","code":"flatten()"},{"text":" instead. However, it is preferable to follow the lead of the Swift standard libraryâ€™s ","type":"text"},{"type":"codeVoice","code":"joined()"},{"text":" method.","type":"text"}],"type":"paragraph"},{"anchor":"CreditsInspiration","type":"heading","level":2,"text":"Credits\/Inspiration"},{"inlineContent":[{"text":"The Swift standard library has functions on synchronous sequences (","type":"text"},{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/sequence\/1641166-joined","isActive":true,"type":"reference"},{"text":", ","type":"text"},{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/sequence\/2431985-joined","isActive":true,"type":"reference"},{"text":") that perform similar (but synchronous) tasks.","type":"text"}],"type":"paragraph"}]}],"kind":"article","schemaVersion":{"major":0,"minor":3,"patch":0},"references":{"https://github.com/apple/swift-async-algorithms/blob/main/Tests/AsyncAlgorithmsTests/TestJoin.swift":{"titleInlineContent":[{"type":"text","text":"Tests"}],"url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestJoin.swift","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestJoin.swift","title":"Tests","type":"link"},"https://developer.apple.com/documentation/swift/sequence/1641166-joined":{"url":"https:\/\/developer.apple.com\/documentation\/swift\/sequence\/1641166-joined","type":"link","title":"joined()","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/sequence\/1641166-joined","titleInlineContent":[{"code":"joined()","type":"codeVoice"}]},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Chunked":{"title":"Chunked","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chunked","kind":"article","url":"\/documentation\/asyncalgorithms\/chunked","role":"article","type":"topic","abstract":[]},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Debounce":{"title":"Debounce","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Debounce","kind":"article","url":"\/documentation\/asyncalgorithms\/debounce","role":"article","type":"topic","abstract":[]},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Channel":{"url":"\/documentation\/asyncalgorithms\/channel","type":"topic","title":"Channel","abstract":[],"kind":"article","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Channel"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/RemoveDuplicates":{"url":"\/documentation\/asyncalgorithms\/removeduplicates","type":"topic","title":"RemoveDuplicates","abstract":[],"kind":"article","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/RemoveDuplicates"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/CombineLatest":{"title":"Combine Latest","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/CombineLatest","kind":"article","url":"\/documentation\/asyncalgorithms\/combinelatest","role":"article","type":"topic","abstract":[{"type":"text","text":"Combines the latest values produced from two or more asynchronous sequences into an asynchronous sequence of tuples."}]},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Chain":{"url":"\/documentation\/asyncalgorithms\/chain","type":"topic","title":"Chain","abstract":[{"text":"Chains two or more asynchronous sequences together sequentially.","type":"text"}],"kind":"article","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chain"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Compacted":{"title":"Compacted","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Compacted","kind":"article","url":"\/documentation\/asyncalgorithms\/compacted","role":"article","type":"topic","abstract":[]},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/AdjacentPairs":{"url":"\/documentation\/asyncalgorithms\/adjacentpairs","type":"topic","title":"AdjacentPairs","abstract":[],"kind":"article","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AdjacentPairs"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Merge":{"role":"article","abstract":[{"text":"Merges two or more asynchronous sequences sharing the same element type into one singular asynchronous sequence.","type":"text"}],"type":"topic","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Merge","url":"\/documentation\/asyncalgorithms\/merge","kind":"article","title":"Merge"},"https://developer.apple.com/documentation/swift/sequence/2431985-joined":{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/sequence\/2431985-joined","url":"https:\/\/developer.apple.com\/documentation\/swift\/sequence\/2431985-joined","title":"joined(separator:)","titleInlineContent":[{"code":"joined(separator:)","type":"codeVoice"}],"type":"link"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/BufferedBytes":{"title":"AsyncBufferedByteIterator","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/BufferedBytes","kind":"article","url":"\/documentation\/asyncalgorithms\/bufferedbytes","role":"article","type":"topic","abstract":[{"type":"text","text":"Provides a highly efficient iterator useful for iterating byte sequences derived from asynchronous read functions."}]},"https://github.com/apple/swift-async-algorithms/blob/main/Sources/AsyncAlgorithms/AsyncJoinedSequence.swift":{"titleInlineContent":[{"type":"text","text":"Source"}],"url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/AsyncJoinedSequence.swift","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/AsyncJoinedSequence.swift","title":"Source","type":"link"},"https://github.com/kperryua":{"url":"https:\/\/github.com\/kperryua","type":"link","title":"Kevin Perry","identifier":"https:\/\/github.com\/kperryua","titleInlineContent":[{"text":"Kevin Perry","type":"text"}]},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Effects":{"url":"\/documentation\/asyncalgorithms\/effects","type":"topic","title":"Effects","abstract":[{"text":"Lists the effects of all async algorithms.","type":"text"}],"kind":"article","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Effects"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Reductions":{"title":"Reductions","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Reductions","kind":"article","url":"\/documentation\/asyncalgorithms\/reductions","role":"article","type":"topic","abstract":[]},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Collections":{"url":"\/documentation\/asyncalgorithms\/collections","type":"topic","title":"Collection Initializers","abstract":[],"kind":"article","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Collections"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Lazy":{"title":"AsyncSyncSequence","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Lazy","kind":"article","url":"\/documentation\/asyncalgorithms\/lazy","role":"article","type":"topic","abstract":[{"type":"text","text":"This operation is available for all "},{"type":"codeVoice","code":"Sequence"},{"type":"text","text":" types."}]},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms":{"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms","kind":"symbol","role":"collection","url":"\/documentation\/asyncalgorithms","title":"AsyncAlgorithms","abstract":[{"type":"strong","inlineContent":[{"text":"Swift Async Algorithms","type":"text"}]},{"type":"text","text":" is an open-source package of asynchronous sequence and advanced algorithms that involve concurrency, along with their related types."}],"type":"topic"},"https://github.com/apple/swift-algorithms/blob/main/Guides/Joined.md":{"identifier":"https:\/\/github.com\/apple\/swift-algorithms\/blob\/main\/Guides\/Joined.md","url":"https:\/\/github.com\/apple\/swift-algorithms\/blob\/main\/Guides\/Joined.md","title":"additional synchronous variants of joined()","titleInlineContent":[{"text":"additional synchronous variants of ","type":"text"},{"code":"joined()","type":"codeVoice"}],"type":"link"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Intersperse":{"title":"Intersperse","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Intersperse","kind":"article","url":"\/documentation\/asyncalgorithms\/intersperse","role":"article","type":"topic","abstract":[{"type":"text","text":"Places a given value in between each element of the asynchronous sequence."}]}}}