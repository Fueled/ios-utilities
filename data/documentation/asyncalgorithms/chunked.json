{"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chunked"},"sections":[],"metadata":{"roleHeading":"Article","title":"Chunked","modules":[{"name":"AsyncAlgorithms"}],"role":"article"},"variants":[{"paths":["\/documentation\/asyncalgorithms\/chunked"],"traits":[{"interfaceLanguage":"swift"}]}],"primaryContentSections":[{"content":[{"anchor":"overview","text":"Overview","level":2,"type":"heading"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Author(s): "},{"type":"reference","identifier":"https:\/\/github.com\/kperryua","isActive":true}]}]}]},{"inlineContent":[{"type":"text","text":"["},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/AsyncChunkedByGroupSequence.swift"},{"type":"text","text":","},{"type":"text","text":" "},{"isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/AsyncChunkedOnProjectionSequence.swift","type":"reference"},{"type":"text","text":","},{"type":"text","text":" "},{"isActive":true,"overridingTitle":"Source","type":"reference","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/AsyncChunkedOnProjectionSequence.swift","overridingTitleInlineContent":[{"type":"text","text":"Source"}]},{"text":",","type":"text"},{"text":" ","type":"text"},{"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/AsyncChunksOfCountAndSignalSequence.swift","isActive":true,"type":"reference"},{"text":",","type":"text"},{"text":" ","type":"text"},{"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/AsyncChunksOfCountSequence.swift","type":"reference","isActive":true},{"text":" |","type":"text"},{"text":" ","type":"text"},{"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestChunk.swift","type":"reference","isActive":true},{"text":" ","type":"text"},{"text":"]","type":"text"}],"type":"paragraph"},{"level":2,"text":"Introduction","type":"heading","anchor":"Introduction"},{"inlineContent":[{"text":"Grouping of values from an asynchronous sequence is often useful for tasks that involve writing those values efficiently or useful to handle specific structured data inputs.","type":"text"}],"type":"paragraph"},{"level":2,"text":"Proposed Solution","type":"heading","anchor":"Proposed-Solution"},{"inlineContent":[{"type":"text","text":"Chunking operations can be broken down into a few distinct categories: grouping according to a binary predicate used to determine whether consecutive elements belong to the same group, projecting an element’s property to determine the element’s chunk membership, by discrete count, by another signal asynchronous sequence which indicates when the chunk should be delimited, or by a combination of count and signal."}],"type":"paragraph"},{"level":3,"text":"Grouping","type":"heading","anchor":"Grouping"},{"inlineContent":[{"type":"text","text":"Group chunks are determined by passing two consecutive elements to a closure which tests whether they are in the same group. When the "},{"code":"AsyncChunkedByGroupSequence","type":"codeVoice"},{"text":" iterator receives the first element from the base sequence, it will immediately be added to a group. When it receives the second item, it tests whether the previous item and the current item belong to the same group. If they are not in the same group, then the iterator emits the first item’s group and a new group is created containing the second item. Items declared to be in the same group accumulate until a new group is declared, or the iterator finds the end of the base sequence. When the base sequence terminates, the final group is emitted. If the base sequence throws an error, ","type":"text"},{"code":"AsyncChunkedByGroupSequence","type":"codeVoice"},{"text":" will rethrow that error immediately and discard any current group.","type":"text"}],"type":"paragraph"},{"code":["extension AsyncSequence {","  public func chunked<Collected: RangeReplaceableCollection>(","    into: Collected.Type,","  \tby belongInSameGroup: @escaping @Sendable (Element, Element) -> Bool ","  ) -> AsyncChunkedByGroupSequence<Self, Collected> ","  \twhere Collected.Element == Element","","  public func chunked(","  \tby belongInSameGroup: @escaping @Sendable (Element, Element) -> Bool","  ) -> AsyncChunkedByGroupSequence<Self, [Element]>","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"Consider an example where an asynchronous sequence emits the following values: "},{"type":"codeVoice","code":"10, 20, 30, 10, 40, 40, 10, 20"},{"type":"text","text":". Given the chunked operation to be defined as follows:"}],"type":"paragraph"},{"code":["let chunks = numbers.chunked { $0 <= $1 }","for await numberChunk in chunks {","  print(numberChunk)","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"That snippet will produce the following values:"}],"type":"paragraph"},{"code":["[10, 20, 30]","[10, 40, 40]","[10, 20]"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"While ","type":"text"},{"code":"Array","type":"codeVoice"},{"text":" is the default type for chunks, thanks to the overload that takes a ","type":"text"},{"code":"RangeReplaceableCollection","type":"codeVoice"},{"text":" type, the same sample can be chunked into instances of ","type":"text"},{"type":"codeVoice","code":"ContiguousArray"},{"type":"text","text":", or any other "},{"type":"codeVoice","code":"RangeReplaceableCollection"},{"type":"text","text":" instead."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let chunks = numbers.chunked(into: ContiguousArray.self) { $0 <= $1 }","for await numberChunk in chunks {","  print(numberChunk)","}"]},{"type":"paragraph","inlineContent":[{"text":"That variant is the funnel method for the main implementation, which passes ","type":"text"},{"code":"[Element].self","type":"codeVoice"},{"text":" in as the parameter.","type":"text"}]},{"type":"heading","text":"Projection","level":3,"anchor":"Projection"},{"type":"paragraph","inlineContent":[{"text":"In some scenarios, chunks are determined not by comparing different elements, but by the element itself. This may be the case when the element has some sort of discriminator that can determine the chunk it belongs to. When two consecutive elements have different projections, the current chunk is emitted and a new chunk is created for the new element.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"When the ","type":"text"},{"code":"AsyncChunkedOnProjectionSequence","type":"codeVoice"},{"type":"text","text":"’s iterator receives "},{"code":"nil","type":"codeVoice"},{"type":"text","text":" from the base sequence, it emits the final chunk. When the base sequence throws an error, the iterator discards the current chunk and rethrows that error."}]},{"type":"paragraph","inlineContent":[{"text":"Similarly to the ","type":"text"},{"code":"chunked(by:)","type":"codeVoice"},{"text":" method this algorithm has an optional specification for the ","type":"text"},{"code":"RangeReplaceableCollection","type":"codeVoice"},{"text":" which is used as the type of each chunk.","type":"text"}]},{"type":"codeListing","code":["extension AsyncSequence {","  public func chunked<Subject : Equatable, Collected: RangeReplaceableCollection>(","    into: Collected.Type,","    on projection: @escaping @Sendable (Element) -> Subject","  ) -> AsyncChunkedOnProjectionSequence<Self, Subject, Collected>","  ","  public func chunked<Subject : Equatable>(","  \ton projection: @escaping @Sendable (Element) -> Subject","  ) -> AsyncChunkedOnProjectionSequence<Self, Subject, [Element]>","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The following example shows how a sequence of names can be chunked together by their first characters."}]},{"type":"codeListing","code":["let names = URL(fileURLWithPath: \"\/tmp\/names.txt\").lines","let groupedNames = names.chunked(on: \\.first!)","for try await (firstLetter, names) in groupedNames {","  print(firstLetter)","  for name in names {","    print(\"  \", name)","  }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A special property of this kind of projection chunking is that when an asynchronous sequence’s elements are known to be ordered, the output of the chunking asynchronous sequence is suitable for initializing dictionaries using the "},{"type":"codeVoice","code":"AsyncSequence"},{"type":"text","text":" initializer for "},{"type":"codeVoice","code":"Dictionary"},{"type":"text","text":". This is because the projection can be easily designed to match the sorting characteristics and thereby guarantee that the output matches the pattern of an array of pairs of unique “keys” with the chunks as the “values”."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the example above, if the names are known to be ordered then you can take advantage of the uniqueness of each “first character” projection to initialize a "},{"type":"codeVoice","code":"Dictionary"},{"type":"text","text":" like so:"}]},{"type":"codeListing","code":["let names = URL(fileURLWithPath: \"\/tmp\/names.txt\").lines","let nameDirectory = try await Dictionary(uniqueKeysWithValues: names.chunked(on: \\.first!))"],"syntax":"swift"},{"type":"heading","anchor":"Count-or-Signal","level":3,"text":"Count or Signal"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Sometimes chunks are determined not by the elements themselves, but by external factors. This final category enables limiting chunks to a specific size and\/or delimiting them by another asynchronous sequence which is referred to as a “signal”. This particular chunking family is useful for scenarios where the elements are more efficiently processed as chunks than individual elements, regardless of their values."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This family is broken down into two sub-families of methods: ones that employ a signal plus an optional count (which return an "},{"type":"codeVoice","code":"AsyncChunksOfCountOrSignalSequence"},{"type":"text","text":"), and the ones that only deal with counts (which return an "},{"type":"codeVoice","code":"AsyncChunksOfCountSequence"},{"type":"text","text":"). Both sub-families have "},{"type":"codeVoice","code":"Collected"},{"type":"text","text":" as their element type, or "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" if unspecified. These sub-families have rethrowing behaviors; if the base "},{"type":"codeVoice","code":"AsyncSequence"},{"type":"text","text":" can throw then the chunks sequence can also throw. Likewise if the base "},{"type":"codeVoice","code":"AsyncSequence"},{"type":"text","text":" cannot throw then the chunks sequence also cannot throw."}]},{"text":"Count only","anchor":"Count-only","type":"heading","level":5},{"code":["extension AsyncSequence {","  public func chunks<Collected: RangeReplaceableCollection>(","    ofCount count: Int, ","    into: Collected.Type","  ) -> AsyncChunksOfCountSequence<Self, Collected> ","    where Collected.Element == Element","","  public func chunks(","    ofCount count: Int","  ) -> AsyncChunksOfCountSequence<Self, [Element]>","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"If a chunk size limit is specified via an ","type":"text"},{"code":"ofCount","type":"codeVoice"},{"text":" parameter, the sequence will produce chunks of type ","type":"text"},{"type":"codeVoice","code":"Collected"},{"type":"text","text":" with at most the specified number of elements. When a chunk reaches the given size, the asynchronous sequence will emit it immediately."}],"type":"paragraph"},{"inlineContent":[{"text":"For example, an asynchronous sequence of ","type":"text"},{"code":"UInt8","type":"codeVoice"},{"text":" bytes can be chunked into at most 1024-byte ","type":"text"},{"code":"Data","type":"codeVoice"},{"text":" instances like so:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let packets = bytes.chunks(ofCount: 1024, into: Data.self)","for try await packet in packets {","  write(packet)","}"]},{"level":5,"text":"Signal only","anchor":"Signal-only","type":"heading"},{"syntax":"swift","type":"codeListing","code":["extension AsyncSequence {","  public func chunked<Signal, Collected: RangeReplaceableCollection>(","    by signal: Signal, ","    into: Collected.Type","  ) -> AsyncChunksOfCountOrSignalSequence<Self, Collected, Signal> ","    where Collected.Element == Element","","  public func chunked<Signal>(","    by signal: Signal","  ) -> AsyncChunksOfCountOrSignalSequence<Self, [Element], Signal>","","  public func chunked<C: Clock, Collected: RangeReplaceableCollection>(","    by timer: AsyncTimerSequence<C>, ","    into: Collected.Type","  ) -> AsyncChunksOfCountOrSignalSequence<Self, Collected, AsyncTimerSequence<C>> ","    where Collected.Element == Element","","  public func chunked<C: Clock>(","    by timer: AsyncTimerSequence<C>","  ) -> AsyncChunksOfCountOrSignalSequence<Self, [Element], AsyncTimerSequence<C>>","}"]},{"inlineContent":[{"text":"If a signal asynchronous sequence is specified, the chunking asynchronous sequence emits chunks whenever the signal emits. The signals element values are ignored. If the chunking asynchronous sequence hasn’t accumulated any elements since its previous emission, then no value is emitted in response to the signal.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Since time is a frequent method of signaling desired delineations of chunks, there is a pre-specialized set of overloads that take "},{"type":"codeVoice","code":"AsyncTimerSequence"},{"type":"text","text":". These allow shorthand initialization by using "},{"type":"codeVoice","code":"AsyncTimerSequence"},{"type":"text","text":"’s static member initializers."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"As an example, an asynchronous sequence of log messages can be chunked into arrays of logs in four second segments like so:"}]},{"type":"codeListing","code":["let fourSecondsOfLogs = logs.chunked(by: .repeating(every: .seconds(4)))","for await chunk in fourSecondsOfLogs {","  send(chunk)","}"],"syntax":"swift"},{"level":5,"type":"heading","text":"Count or Signal","anchor":"Count-or-Signal"},{"type":"codeListing","code":["extension AsyncSequence {","  public func chunks<Signal, Collected: RangeReplaceableCollection>(","    ofCount count: Int, ","    or signal: Signal, ","    into: Collected.Type","  ) -> AsyncChunksOfCountOrSignalSequence<Self, Collected, Signal> ","    where Collected.Element == Element","","  public func chunks<Signal>(","    ofCount count: Int, ","    or signal: Signal","  ) -> AsyncChunksOfCountOrSignalSequence<Self, [Element], Signal>","","  public func chunked<C: Clock, Collected: RangeReplaceableCollection>(","    by timer: AsyncTimerSequence<C>, ","    into: Collected.Type","  ) -> AsyncChunksOfCountOrSignalSequence<Self, Collected, AsyncTimerSequence<C>> ","    where Collected.Element == Element","","  public func chunked<C: Clock>(","    by timer: AsyncTimerSequence<C>","  ) -> AsyncChunksOfCountOrSignalSequence<Self, [Element], AsyncTimerSequence<C>>","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"If both count and signal are specified, the chunking asynchronous sequence emits chunks whenever ","type":"text"},{"inlineContent":[{"text":"either","type":"text"}],"type":"emphasis"},{"text":" the chunk reaches the specified size ","type":"text"},{"inlineContent":[{"text":"or","type":"text"}],"type":"emphasis"},{"text":" the signal asynchronous sequence emits. When a signal causes a chunk to be emitted, the accumulated element count is reset back to zero. When an ","type":"text"},{"code":"AsyncTimerSequence","type":"codeVoice"},{"text":" is used as a signal, the timer is started from the moment ","type":"text"},{"code":"next()","type":"codeVoice"},{"text":" is called for the first time on ","type":"text"},{"code":"AsyncChunksOfCountOrSignalSequence","type":"codeVoice"},{"text":"‘s iterator, and it emits on a regular cadence from that moment. Note that the scheduling of the timer’s emission is unaffected by any chunks emitted based on count.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Like the example above, this code emits up to 1024-byte "},{"type":"codeVoice","code":"Data"},{"type":"text","text":" instances, but a chunk will also be emitted every second."}]},{"type":"codeListing","code":["let packets = bytes.chunks(ofCount: 1024, or: .repeating(every: .seconds(1)), into: Data.self)","for try await packet in packets {","  write(packet)","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In any configuration of any of the chunking families, when the base asynchronous sequence terminates, one of two things will happen: 1) a partial chunk will be emitted, or 2) no chunk will be emitted (i.e. the iterator received no elements since the emission of the previous chunk). No elements from the base asynchronous sequence are ever discarded, except in the case of a thrown error."}]},{"level":2,"type":"heading","text":"Detailed Design","anchor":"Detailed-Design"},{"level":3,"type":"heading","text":"Grouping","anchor":"Grouping"},{"type":"codeListing","code":["public struct AsyncChunkedByGroupSequence<Base: AsyncSequence, Collected: RangeReplaceableCollection>: AsyncSequence ","  where Collected.Element == Base.Element {","  public typealias Element = Collected","  ","  public struct Iterator: AsyncIteratorProtocol {","    public mutating func next() async rethrows -> Collected?","  }","  ","  public func makeAsyncIterator() -> Iterator","}","","extension AsyncChunkedByGroupSequence: Sendable ","  where Base: Sendable, Base.Element: Sendable { }","  ","extension AsyncChunkedByGroupSequence.Iterator: Sendable ","  where Base.AsyncIterator: Sendable, Base.Element: Sendable { }"],"syntax":"swift"},{"level":3,"type":"heading","text":"Projection","anchor":"Projection"},{"type":"codeListing","code":["public struct AsyncChunkedOnProjectionSequence<Base: AsyncSequence, Subject: Equatable, Collected: RangeReplaceableCollection>: AsyncSequence where Collected.Element == Base.Element {","  public typealias Element = (Subject, Collected)","","  public struct Iterator: AsyncIteratorProtocol {","    public mutating func next() async rethrows -> (Subject, Collected)?","  }","","  public func makeAsyncIterator() -> Iterator","}","","extension AsyncChunkedOnProjectionSequence: Sendable ","  where Base: Sendable, Base.Element: Sendable { }","extension AsyncChunkedOnProjectionSequence.Iterator: Sendable","  where Base.AsyncIterator: Sendable, Base.Element: Sendable, Subject: Sendable { }"],"syntax":"swift"},{"type":"heading","anchor":"Count","level":3,"text":"Count"},{"type":"codeListing","syntax":"swift","code":["public struct AsyncChunksOfCountSequence<Base: AsyncSequence, Collected: RangeReplaceableCollection>: AsyncSequence ","  where Collected.Element == Base.Element {","  public typealias Element = Collected","","  public struct Iterator: AsyncIteratorProtocol {","    public mutating func next() async rethrows -> Collected?","  }","","  public func makeAsyncIterator() -> Iterator","}","","extension AsyncChunksOfCountSequence : Sendable where Base : Sendable, Base.Element : Sendable { }","extension AsyncChunksOfCountSequence.Iterator : Sendable where Base.AsyncIterator : Sendable, Base.Element : Sendable { }",""]},{"type":"heading","anchor":"Count-or-Signal","level":3,"text":"Count or Signal"},{"type":"codeListing","syntax":"swift","code":["public struct AsyncChunksOfCountOrSignalSequence<Base: AsyncSequence, Collected: RangeReplaceableCollection, Signal: AsyncSequence>: AsyncSequence, Sendable ","  where ","    Collected.Element == Base.Element, ","    Base: Sendable, Signal: Sendable, ","    Base.AsyncIterator: Sendable, Signal.AsyncIterator: Sendable, ","    Base.Element: Sendable, Signal.Element: Sendable {","  public typealias Element = Collected","","  public struct Iterator: AsyncIteratorProtocol, Sendable {","    public mutating func next() async rethrows -> Collected?","  }","  ","  public func makeAsyncIterator() -> Iterator","}"]},{"type":"heading","anchor":"Alternatives-Considered","level":2,"text":"Alternatives Considered"},{"type":"paragraph","inlineContent":[{"text":"It was considered to make the chunked element to be an ","type":"text"},{"code":"AsyncSequence","type":"codeVoice"},{"text":" instead of allowing collection into a ","type":"text"},{"code":"RangeReplaceableCollection","type":"codeVoice"},{"text":" however it was determined that the throwing behavior of that would be complex to understand. If that hurdle could be overcome then that might be a future direction\/consideration that would be worth exploring.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Variants of "},{"type":"codeVoice","code":"chunked(by:)"},{"type":"text","text":" (grouping) and "},{"type":"codeVoice","code":"chunked(on:)"},{"type":"text","text":" (projection) methods could be added that take delimiting "},{"type":"codeVoice","code":"Signal"},{"type":"text","text":" and "},{"type":"codeVoice","code":"AsyncTimerSequence"},{"type":"text","text":" inputs similar to "},{"type":"codeVoice","code":"chunked(byCount:or:)"},{"type":"text","text":". However, it was decided that such functionality was likely to be underutilized and not worth the complication to the already broad surface area of "},{"type":"codeVoice","code":"chunked"},{"type":"text","text":" methods."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The naming of this family was considered to be "},{"code":"collect","type":"codeVoice"},{"type":"text","text":" which is used in APIs like "},{"code":"Combine","type":"codeVoice"},{"type":"text","text":". This family of functions has distinct similarity to those APIs."}]},{"type":"heading","anchor":"CreditsInspiration","level":2,"text":"Credits\/Inspiration"},{"type":"paragraph","inlineContent":[{"text":"This transformation function is a heavily inspired analog of the synchronous version ","type":"text"},{"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-algorithms\/blob\/main\/Guides\/Chunked.md","isActive":true}]}],"kind":"content"}],"schemaVersion":{"major":0,"patch":0,"minor":3},"kind":"article","seeAlsoSections":[{"title":"Getting Started","identifiers":["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AdjacentPairs","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/BufferedBytes","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chain","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Channel","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Collections","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/CombineLatest","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Compacted","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Debounce","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Effects","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Intersperse","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Joined","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Lazy","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Merge","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Reductions","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/RemoveDuplicates"],"generated":true,"anchor":"Getting-Started"}],"hierarchy":{"paths":[["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms"]]},"references":{"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Debounce":{"title":"Debounce","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Debounce","kind":"article","url":"\/documentation\/asyncalgorithms\/debounce","role":"article","type":"topic","abstract":[]},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Collections":{"url":"\/documentation\/asyncalgorithms\/collections","type":"topic","title":"Collection Initializers","abstract":[],"kind":"article","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Collections"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/BufferedBytes":{"title":"AsyncBufferedByteIterator","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/BufferedBytes","kind":"article","url":"\/documentation\/asyncalgorithms\/bufferedbytes","role":"article","type":"topic","abstract":[{"type":"text","text":"Provides a highly efficient iterator useful for iterating byte sequences derived from asynchronous read functions."}]},"https://github.com/apple/swift-async-algorithms/blob/main/Sources/AsyncAlgorithms/AsyncChunkedOnProjectionSequence.swift":{"type":"link","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/AsyncChunkedOnProjectionSequence.swift","titleInlineContent":[{"type":"text","text":"Source"}],"url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/AsyncChunkedOnProjectionSequence.swift","title":"Source"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Merge":{"role":"article","abstract":[{"text":"Merges two or more asynchronous sequences sharing the same element type into one singular asynchronous sequence.","type":"text"}],"type":"topic","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Merge","url":"\/documentation\/asyncalgorithms\/merge","kind":"article","title":"Merge"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Channel":{"url":"\/documentation\/asyncalgorithms\/channel","type":"topic","title":"Channel","abstract":[],"kind":"article","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Channel"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Compacted":{"title":"Compacted","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Compacted","kind":"article","url":"\/documentation\/asyncalgorithms\/compacted","role":"article","type":"topic","abstract":[]},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Reductions":{"title":"Reductions","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Reductions","kind":"article","url":"\/documentation\/asyncalgorithms\/reductions","role":"article","type":"topic","abstract":[]},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Effects":{"url":"\/documentation\/asyncalgorithms\/effects","type":"topic","title":"Effects","abstract":[{"text":"Lists the effects of all async algorithms.","type":"text"}],"kind":"article","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Effects"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms":{"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms","kind":"symbol","role":"collection","url":"\/documentation\/asyncalgorithms","title":"AsyncAlgorithms","abstract":[{"type":"strong","inlineContent":[{"text":"Swift Async Algorithms","type":"text"}]},{"type":"text","text":" is an open-source package of asynchronous sequence and advanced algorithms that involve concurrency, along with their related types."}],"type":"topic"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/RemoveDuplicates":{"url":"\/documentation\/asyncalgorithms\/removeduplicates","type":"topic","title":"RemoveDuplicates","abstract":[],"kind":"article","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/RemoveDuplicates"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Lazy":{"title":"AsyncSyncSequence","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Lazy","kind":"article","url":"\/documentation\/asyncalgorithms\/lazy","role":"article","type":"topic","abstract":[{"type":"text","text":"This operation is available for all "},{"type":"codeVoice","code":"Sequence"},{"type":"text","text":" types."}]},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/CombineLatest":{"title":"Combine Latest","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/CombineLatest","kind":"article","url":"\/documentation\/asyncalgorithms\/combinelatest","role":"article","type":"topic","abstract":[{"type":"text","text":"Combines the latest values produced from two or more asynchronous sequences into an asynchronous sequence of tuples."}]},"https://github.com/apple/swift-async-algorithms/blob/main/Tests/AsyncAlgorithmsTests/TestChunk.swift":{"titleInlineContent":[{"text":"Tests","type":"text"}],"url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestChunk.swift","title":"Tests","type":"link","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestChunk.swift"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/AdjacentPairs":{"url":"\/documentation\/asyncalgorithms\/adjacentpairs","type":"topic","title":"AdjacentPairs","abstract":[],"kind":"article","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AdjacentPairs"},"https://github.com/apple/swift-async-algorithms/blob/main/Sources/AsyncAlgorithms/AsyncChunksOfCountSequence.swift":{"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/AsyncChunksOfCountSequence.swift","title":"Source","titleInlineContent":[{"type":"text","text":"Source"}],"type":"link","url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/AsyncChunksOfCountSequence.swift"},"https://github.com/apple/swift-algorithms/blob/main/Guides/Chunked.md":{"type":"link","identifier":"https:\/\/github.com\/apple\/swift-algorithms\/blob\/main\/Guides\/Chunked.md","titleInlineContent":[{"type":"text","text":"defined in the Swift Algorithms package"}],"url":"https:\/\/github.com\/apple\/swift-algorithms\/blob\/main\/Guides\/Chunked.md","title":"defined in the Swift Algorithms package"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Joined":{"title":"Joined","url":"\/documentation\/asyncalgorithms\/joined","type":"topic","abstract":[],"kind":"article","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Joined"},"https://github.com/apple/swift-async-algorithms/blob/main/Sources/AsyncAlgorithms/AsyncChunksOfCountAndSignalSequence.swift":{"type":"link","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/AsyncChunksOfCountAndSignalSequence.swift","titleInlineContent":[{"text":"Source","type":"text"}],"url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/AsyncChunksOfCountAndSignalSequence.swift","title":"Source"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Intersperse":{"title":"Intersperse","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Intersperse","kind":"article","url":"\/documentation\/asyncalgorithms\/intersperse","role":"article","type":"topic","abstract":[{"type":"text","text":"Places a given value in between each element of the asynchronous sequence."}]},"https://github.com/apple/swift-async-algorithms/blob/main/Sources/AsyncAlgorithms/AsyncChunkedByGroupSequence.swift":{"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/AsyncChunkedByGroupSequence.swift","title":"Source","titleInlineContent":[{"type":"text","text":"Source"}],"type":"link","url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/AsyncChunkedByGroupSequence.swift"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Chain":{"url":"\/documentation\/asyncalgorithms\/chain","type":"topic","title":"Chain","abstract":[{"text":"Chains two or more asynchronous sequences together sequentially.","type":"text"}],"kind":"article","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chain"},"https://github.com/kperryua":{"url":"https:\/\/github.com\/kperryua","type":"link","titleInlineContent":[{"type":"text","text":"Kevin Perry"}],"identifier":"https:\/\/github.com\/kperryua","title":"Kevin Perry"}}}