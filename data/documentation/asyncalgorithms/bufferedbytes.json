{"seeAlsoSections":[{"generated":true,"anchor":"Getting-Started","identifiers":["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AdjacentPairs","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chain","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Channel","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chunked","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Collections","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/CombineLatest","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Compacted","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Debounce","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Effects","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Intersperse","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Joined","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Lazy","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Merge","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Reductions","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/RemoveDuplicates"],"title":"Getting Started"}],"identifier":{"url":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/BufferedBytes","interfaceLanguage":"swift"},"metadata":{"role":"article","title":"AsyncBufferedByteIterator","roleHeading":"Article","modules":[{"name":"AsyncAlgorithms"}]},"primaryContentSections":[{"kind":"content","content":[{"type":"heading","level":2,"text":"Overview","anchor":"overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"["},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/AsyncBufferedByteIterator.swift"},{"type":"text","text":" |"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestBufferedByteIterator.swift"},{"type":"text","text":"]"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This type provides infrastructure for creating "},{"type":"codeVoice","code":"AsyncSequence"},{"type":"text","text":" types with an "},{"type":"codeVoice","code":"Element"},{"type":"text","text":" of "},{"type":"codeVoice","code":"UInt8"},{"type":"text","text":" backed by file descriptors or similar read sources."}]},{"type":"codeListing","syntax":"swift","code":["struct AsyncBytes: AsyncSequence {","  public typealias Element = UInt8","  var handle: ReadableThing","","  internal init(_ readable: ReadableThing) {","    handle = readable","  }","","  public func makeAsyncIterator() -> AsyncBufferedByteIterator {","    return AsyncBufferedByteIterator(capacity: 16384) { buffer in","      \/\/ This runs once every 16384 invocations of next()","      return try await handle.read(into: buffer)","    }","  }","}"]},{"type":"heading","level":2,"text":"Detailed Design","anchor":"Detailed-Design"},{"type":"codeListing","syntax":"swift","code":["public struct AsyncBufferedByteIterator: AsyncIteratorProtocol, Sendable {","  public typealias Element = UInt8","","  public init(","    capacity: Int,","    readFunction: @Sendable @escaping (UnsafeMutableRawBufferPointer) async throws -> Int","  )","","  public mutating func next() async throws -> UInt8?","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For each invocation of "},{"code":"next","type":"codeVoice"},{"type":"text","text":", the iterator will check if a buffer has been filled. If the buffer is filled with some amount of bytes, a fast path is taken to directly return a byte out of that buffer. If the buffer is not filled, the read function is invoked to acquire the next filled buffer, at which point it takes a byte out of that buffer."}]},{"inlineContent":[{"type":"text","text":"If the read function returns "},{"type":"codeVoice","code":"0"},{"type":"text","text":", indicating it didnâ€™t read any more bytes, the iterator is decided to be finished and no additional invocations to the read function are made."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"If the read function throws, the error will be thrown by the iteration. Subsequent invocations to the iterator will then return "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" without invoking the read function."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"If the task is cancelled during the iteration, the iteration will check the cancellation only in passes where the read function is invoked, and will throw a "},{"type":"codeVoice","code":"CancellationError"},{"type":"text","text":"."}],"type":"paragraph"},{"level":3,"anchor":"Naming","text":"Naming","type":"heading"},{"inlineContent":[{"type":"text","text":"This type was named precisely for what it does: it is an asynchronous iterator that buffers bytes."}],"type":"paragraph"}]}],"kind":"article","sections":[],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/asyncalgorithms\/bufferedbytes"]}],"abstract":[{"type":"text","text":"Provides a highly efficient iterator useful for iterating byte sequences derived from asynchronous read functions."}],"hierarchy":{"paths":[["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms"]]},"schemaVersion":{"major":0,"minor":3,"patch":0},"references":{"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/RemoveDuplicates":{"title":"RemoveDuplicates","abstract":[],"url":"\/documentation\/asyncalgorithms\/removeduplicates","type":"topic","kind":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/RemoveDuplicates","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Channel":{"title":"Channel","abstract":[],"url":"\/documentation\/asyncalgorithms\/channel","type":"topic","kind":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Channel","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Effects":{"title":"Effects","abstract":[{"text":"Lists the effects of all async algorithms.","type":"text"}],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Effects","kind":"article","type":"topic","url":"\/documentation\/asyncalgorithms\/effects","role":"article"},"https://github.com/apple/swift-async-algorithms/blob/main/Sources/AsyncAlgorithms/AsyncBufferedByteIterator.swift":{"type":"link","url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/AsyncBufferedByteIterator.swift","titleInlineContent":[{"text":"Source","type":"text"}],"title":"Source","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/AsyncBufferedByteIterator.swift"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Chain":{"title":"Chain","abstract":[{"type":"text","text":"Chains two or more asynchronous sequences together sequentially."}],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chain","type":"topic","url":"\/documentation\/asyncalgorithms\/chain","kind":"article","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Debounce":{"title":"Debounce","type":"topic","url":"\/documentation\/asyncalgorithms\/debounce","kind":"article","role":"article","abstract":[],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Debounce"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/CombineLatest":{"title":"Combine Latest","type":"topic","url":"\/documentation\/asyncalgorithms\/combinelatest","kind":"article","role":"article","abstract":[{"type":"text","text":"Combines the latest values produced from two or more asynchronous sequences into an asynchronous sequence of tuples."}],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/CombineLatest"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/AdjacentPairs":{"title":"AdjacentPairs","type":"topic","url":"\/documentation\/asyncalgorithms\/adjacentpairs","kind":"article","role":"article","abstract":[],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AdjacentPairs"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Chunked":{"title":"Chunked","type":"topic","url":"\/documentation\/asyncalgorithms\/chunked","kind":"article","role":"article","abstract":[],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chunked"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Joined":{"title":"Joined","abstract":[],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Joined","type":"topic","url":"\/documentation\/asyncalgorithms\/joined","kind":"article","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Collections":{"title":"Collection Initializers","type":"topic","url":"\/documentation\/asyncalgorithms\/collections","kind":"article","role":"article","abstract":[],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Collections"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms":{"type":"topic","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms","title":"AsyncAlgorithms","url":"\/documentation\/asyncalgorithms","kind":"symbol","abstract":[{"inlineContent":[{"type":"text","text":"Swift Async Algorithms"}],"type":"strong"},{"text":" is an open-source package of asynchronous sequence and advanced algorithms that involve concurrency, along with their related types.","type":"text"}],"role":"collection"},"https://github.com/apple/swift-async-algorithms/blob/main/Tests/AsyncAlgorithmsTests/TestBufferedByteIterator.swift":{"type":"link","url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestBufferedByteIterator.swift","titleInlineContent":[{"text":"Tests","type":"text"}],"title":"Tests","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestBufferedByteIterator.swift"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Reductions":{"url":"\/documentation\/asyncalgorithms\/reductions","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Reductions","kind":"article","abstract":[],"title":"Reductions","type":"topic","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Lazy":{"title":"AsyncSyncSequence","abstract":[{"text":"This operation is available for all ","type":"text"},{"code":"Sequence","type":"codeVoice"},{"text":" types.","type":"text"}],"url":"\/documentation\/asyncalgorithms\/lazy","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Lazy","type":"topic","kind":"article","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Merge":{"title":"Merge","type":"topic","url":"\/documentation\/asyncalgorithms\/merge","kind":"article","role":"article","abstract":[{"text":"Merges two or more asynchronous sequences sharing the same element type into one singular asynchronous sequence.","type":"text"}],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Merge"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Intersperse":{"title":"Intersperse","abstract":[{"type":"text","text":"Places a given value in between each element of the asynchronous sequence."}],"url":"\/documentation\/asyncalgorithms\/intersperse","type":"topic","kind":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Intersperse","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Compacted":{"title":"Compacted","type":"topic","url":"\/documentation\/asyncalgorithms\/compacted","kind":"article","role":"article","abstract":[],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Compacted"}}}