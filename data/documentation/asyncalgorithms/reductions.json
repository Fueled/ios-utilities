{"kind":"article","variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/asyncalgorithms\/reductions"]}],"sections":[],"hierarchy":{"paths":[["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms"]]},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Reductions"},"primaryContentSections":[{"content":[{"type":"heading","level":2,"text":"Overview","anchor":"overview"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Author(s): ","type":"text"},{"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/phausler"}]}]}]},{"type":"paragraph","inlineContent":[{"text":"[","type":"text"},{"text":" ","type":"text"},{"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/AsyncExclusiveReductionsSequence.swift","isActive":true,"type":"reference"},{"text":" |","type":"text"},{"text":" ","type":"text"},{"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestReductions.swift","isActive":true,"type":"reference"},{"text":" ","type":"text"},{"text":"]","type":"text"}]},{"type":"heading","level":2,"text":"Introduction","anchor":"Introduction"},{"type":"paragraph","inlineContent":[{"text":"The family of algorithms for reduce are useful for converting a sequence or asynchronous sequence into a single value, but that can elide important intermediate information. The ","type":"text"},{"inlineContent":[{"type":"text","text":"reductions"}],"type":"emphasis"},{"text":" algorithm is often called “scan”, but this name does not convey its heritage to the family of reducing.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"There are two strategies that are usable for creating continuous reductions: exclusive reductions and inclusive reductions:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Exclusive reductions take a value and incorporate values into that initial value. A common example is reductions by appending to an array.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Inclusive reductions transact only on the values provided. A common example is adding numbers.","type":"text"}]}]}]},{"type":"heading","level":2,"text":"Proposed Solution","anchor":"Proposed-Solution"},{"type":"paragraph","inlineContent":[{"text":"Exclusive reductions come in two variants: transforming by application, or transformation via mutation. This replicates the same interface as ","type":"text"},{"code":"reduce(_:_:)","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"reduce(into:_:)","type":"codeVoice"},{"text":". Unlike the ","type":"text"},{"code":"reduce","type":"codeVoice"},{"text":" algorithms, the ","type":"text"},{"code":"reductions","type":"codeVoice"},{"text":" algorithm also comes in two flavors: throwing or non throwing transformations.","type":"text"}]},{"type":"codeListing","code":["extension AsyncSequence {","  public func reductions<Result>(","    _ initial: Result, ","    _ transform: @Sendable @escaping (Result, Element) async -> Result","  ) -> AsyncExclusiveReductionsSequence<Self, Result>","  ","  public func reductions<Result>(","    into initial: Result, ","    _ transform: @Sendable @escaping (inout Result, Element) async -> Void","  ) -> AsyncExclusiveReductionsSequence<Self, Result>","}","","extension AsyncSequence {","  public func reductions<Result>(","    _ initial: Result, ","    _ transform: @Sendable @escaping (Result, Element) async throws -> Result","  ) -> AsyncThrowingExclusiveReductionsSequence<Self, Result>","  ","  public func reductions<Result>(","    into initial: Result, ","    _ transform: @Sendable @escaping (inout Result, Element) async throws -> Void","  ) -> AsyncThrowingExclusiveReductionsSequence<Self, Result>","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"These APIs can be used to reduce an initial value progressively or reduce into an initial value via mutation. In practice, a common use case for reductions is to mutate a collection by appending values.","type":"text"}]},{"type":"codeListing","code":["characters.reductions(into: \"\") { $0.append($1) }"],"syntax":"swift"},{"inlineContent":[{"text":"If the characters being produced asynchronously are ","type":"text"},{"type":"codeVoice","code":"\"a\", \"b\", \"c\""},{"text":", then the iteration of the reductions is ","type":"text"},{"type":"codeVoice","code":"\"a\", \"ab\", \"abc\""},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Inclusive reductions do not have an initial value and therefore do not need an additional variations beyond the throwing and non throwing flavors.","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["extension AsyncSequence {","  public func reductions(","    _ transform: @Sendable @escaping (Element, Element) async -> Element","  ) -> AsyncInclusiveReductionsSequence<Self>","  ","  public func reductions(","    _ transform: @Sendable @escaping (Element, Element) async throws -> Element","  ) -> AsyncThrowingInclusiveReductionsSequence<Self>","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"This is often used for scenarios like a running tally or other similar cases.","type":"text"}]},{"type":"codeListing","code":["numbers.reductions { $0 + $1 }"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the above example, if the numbers are a sequence of "},{"type":"codeVoice","code":"1, 2, 3, 4"},{"type":"text","text":", the produced values would be "},{"type":"codeVoice","code":"1, 3, 6, 10"},{"type":"text","text":"."}]},{"type":"heading","level":2,"text":"Detailed Design","anchor":"Detailed-Design"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The exclusive reduction variants come in two distinct cases: non-throwing and throwing. These both have corresponding types to encompass that throwing behavior."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For non-throwing exclusive reductions, the element type of the sequence is the result of the reduction transform. "},{"type":"codeVoice","code":"AsyncExclusiveReductionsSequence"},{"type":"text","text":" will throw if the base asynchronous sequence throws, and will not throw if the base does not throws."}]},{"type":"codeListing","code":["public struct AsyncExclusiveReductionsSequence<Base: AsyncSequence, Element> {","}","","extension AsyncExclusiveReductionsSequence: AsyncSequence {","  public struct Iterator: AsyncIteratorProtocol {","    public mutating func next() async rethrows -> Element?","  }","  ","  public func makeAsyncIterator() -> Iterator","}","","extension AsyncExclusiveReductionsSequence: Sendable ","  where Base: Sendable, Element: Sendable { }","  ","extension AsyncExclusiveReductionsSequence.Iterator: Sendable ","  where Base.AsyncIterator: Sendable, Element: Sendable { }"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The sendability behavior of "},{"type":"codeVoice","code":"AsyncExclusiveReductionsSequence"},{"type":"text","text":" is such that when the base, base iterator, and element are "},{"type":"codeVoice","code":"Sendable"},{"type":"text","text":" then "},{"type":"codeVoice","code":"AsyncExclusiveReductionsSequence"},{"type":"text","text":" is "},{"type":"codeVoice","code":"Sendable"},{"type":"text","text":"."}]},{"type":"codeListing","code":["public struct AsyncThrowingExclusiveReductionsSequence<Base: AsyncSequence, Element> {","}","","extension AsyncThrowingExclusiveReductionsSequence: AsyncSequence {","  public struct Iterator: AsyncIteratorProtocol {","    public mutating func next() async throws -> Element?","  }","  ","  public func makeAsyncIterator() -> Iterator","}","","extension AsyncThrowingExclusiveReductionsSequence: Sendable ","  where Base: Sendable, Element: Sendable { }","  ","extension AsyncThrowingExclusiveReductionsSequence.Iterator: Sendable ","  where Base.AsyncIterator: Sendable, Element: Sendable { }"],"syntax":"swift"},{"text":"Alternatives Considered","anchor":"Alternatives-Considered","level":2,"type":"heading"},{"inlineContent":[{"type":"text","text":"One alternate name for "},{"type":"codeVoice","code":"reductions"},{"type":"text","text":" was to name it "},{"type":"codeVoice","code":"scan"},{"type":"text","text":"; however the naming from the Swift Algorithms package offers considerably more inference to the heritage of what family of functions this algorithm belongs to."}],"type":"paragraph"},{"type":"heading","level":2,"text":"Credits\/Inspiration","anchor":"CreditsInspiration"},{"type":"paragraph","inlineContent":[{"text":"This transformation function is a direct analog to the synchronous version ","type":"text"},{"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-algorithms\/blob\/main\/Guides\/Reductions.md","isActive":true}]}],"kind":"content"}],"schemaVersion":{"patch":0,"minor":3,"major":0},"seeAlsoSections":[{"title":"Getting Started","anchor":"Getting-Started","identifiers":["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AdjacentPairs","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/BufferedBytes","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chain","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Channel","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chunked","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Collections","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/CombineLatest","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Compacted","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Debounce","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Effects","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Intersperse","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Joined","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Lazy","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Merge","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/RemoveDuplicates"],"generated":true}],"metadata":{"title":"Reductions","roleHeading":"Article","modules":[{"name":"AsyncAlgorithms"}],"role":"article"},"references":{"https://github.com/apple/swift-async-algorithms/blob/main/Tests/AsyncAlgorithmsTests/TestReductions.swift":{"titleInlineContent":[{"text":"Tests","type":"text"}],"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestReductions.swift","url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestReductions.swift","title":"Tests","type":"link"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Intersperse":{"title":"Intersperse","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Intersperse","url":"\/documentation\/asyncalgorithms\/intersperse","abstract":[{"type":"text","text":"Places a given value in between each element of the asynchronous sequence."}],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/RemoveDuplicates":{"title":"RemoveDuplicates","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/RemoveDuplicates","url":"\/documentation\/asyncalgorithms\/removeduplicates","abstract":[],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Joined":{"title":"Joined","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Joined","url":"\/documentation\/asyncalgorithms\/joined","abstract":[],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/BufferedBytes":{"title":"AsyncBufferedByteIterator","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/BufferedBytes","url":"\/documentation\/asyncalgorithms\/bufferedbytes","abstract":[{"type":"text","text":"Provides a highly efficient iterator useful for iterating byte sequences derived from asynchronous read functions."}],"kind":"article"},"https://github.com/apple/swift-async-algorithms/blob/main/Sources/AsyncAlgorithms/AsyncExclusiveReductionsSequence.swift":{"titleInlineContent":[{"text":"Source","type":"text"}],"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/AsyncExclusiveReductionsSequence.swift","url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/AsyncExclusiveReductionsSequence.swift","title":"Source","type":"link"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Merge":{"title":"Merge","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Merge","url":"\/documentation\/asyncalgorithms\/merge","abstract":[{"type":"text","text":"Merges two or more asynchronous sequences sharing the same element type into one singular asynchronous sequence."}],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Chain":{"title":"Chain","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chain","url":"\/documentation\/asyncalgorithms\/chain","abstract":[{"type":"text","text":"Chains two or more asynchronous sequences together sequentially."}],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Debounce":{"title":"Debounce","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Debounce","url":"\/documentation\/asyncalgorithms\/debounce","abstract":[],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Chunked":{"title":"Chunked","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chunked","url":"\/documentation\/asyncalgorithms\/chunked","abstract":[],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/CombineLatest":{"title":"Combine Latest","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/CombineLatest","url":"\/documentation\/asyncalgorithms\/combinelatest","abstract":[{"type":"text","text":"Combines the latest values produced from two or more asynchronous sequences into an asynchronous sequence of tuples."}],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/AdjacentPairs":{"title":"AdjacentPairs","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AdjacentPairs","url":"\/documentation\/asyncalgorithms\/adjacentpairs","abstract":[],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Effects":{"title":"Effects","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Effects","url":"\/documentation\/asyncalgorithms\/effects","abstract":[{"type":"text","text":"Lists the effects of all async algorithms."}],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Collections":{"title":"Collection Initializers","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Collections","url":"\/documentation\/asyncalgorithms\/collections","abstract":[],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Compacted":{"title":"Compacted","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Compacted","url":"\/documentation\/asyncalgorithms\/compacted","abstract":[],"kind":"article"},"https://github.com/apple/swift-algorithms/blob/main/Guides/Reductions.md":{"titleInlineContent":[{"text":"defined in the Swift Algorithms package","type":"text"}],"identifier":"https:\/\/github.com\/apple\/swift-algorithms\/blob\/main\/Guides\/Reductions.md","url":"https:\/\/github.com\/apple\/swift-algorithms\/blob\/main\/Guides\/Reductions.md","title":"defined in the Swift Algorithms package","type":"link"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms":{"type":"topic","abstract":[{"type":"strong","inlineContent":[{"type":"text","text":"Swift Async Algorithms"}]},{"type":"text","text":" is an open-source package of asynchronous sequence and advanced algorithms that involve concurrency, along with their related types."}],"title":"AsyncAlgorithms","kind":"symbol","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms","role":"collection","url":"\/documentation\/asyncalgorithms"},"https://github.com/phausler":{"titleInlineContent":[{"text":"Philippe Hausler","type":"text"}],"identifier":"https:\/\/github.com\/phausler","url":"https:\/\/github.com\/phausler","title":"Philippe Hausler","type":"link"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Lazy":{"title":"AsyncSyncSequence","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Lazy","url":"\/documentation\/asyncalgorithms\/lazy","abstract":[{"type":"text","text":"This operation is available for all "},{"code":"Sequence","type":"codeVoice"},{"type":"text","text":" types."}],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Channel":{"title":"Channel","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Channel","url":"\/documentation\/asyncalgorithms\/channel","abstract":[],"kind":"article"}}}