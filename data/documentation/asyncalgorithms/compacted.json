{"kind":"article","variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/asyncalgorithms\/compacted"]}],"sections":[],"hierarchy":{"paths":[["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms"]]},"identifier":{"url":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Compacted","interfaceLanguage":"swift"},"primaryContentSections":[{"content":[{"level":2,"text":"Overview","type":"heading","anchor":"overview"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Author(s): ","type":"text"},{"isActive":true,"identifier":"https:\/\/github.com\/phausler","type":"reference"}],"type":"paragraph"}]}]},{"inlineContent":[{"type":"text","text":"["},{"type":"text","text":" "},{"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/AsyncCompactedSequence.swift"},{"type":"text","text":" |"},{"type":"text","text":" "},{"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestCompacted.swift"},{"type":"text","text":" "},{"type":"text","text":"]"}],"type":"paragraph"},{"level":2,"text":"Introduction","type":"heading","anchor":"Introduction"},{"inlineContent":[{"type":"text","text":"Just as it is common for "},{"type":"codeVoice","code":"Sequence"},{"type":"text","text":" types that contain optional values to need to "},{"type":"codeVoice","code":".compactMap { $0 }"},{"type":"text","text":", "},{"type":"codeVoice","code":"AsyncSequence"},{"type":"text","text":" types have the same use cases. This common task means that the type must employ a closure to test the optional value. This can be done more efficiently for both execution performance as well as API efficiency of typing."}],"type":"paragraph"},{"level":2,"text":"Proposed Solution","type":"heading","anchor":"Proposed-Solution"},{"inlineContent":[{"type":"text","text":"Similar to the Swift Algorithms package we propose that a new method be added to "},{"type":"codeVoice","code":"AsyncSequence"},{"type":"text","text":" to fit this need."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["extension AsyncSequence {","  public func compacted<Unwrapped>() -> AsyncCompactedSequence<Self, Unwrapped>","    where Element == Unwrapped?","}"]},{"inlineContent":[{"type":"text","text":"This is equivalent to writing "},{"type":"codeVoice","code":".compactMap { $0 }"},{"type":"text","text":" from a behavioral standpoint but is easier to reason about and is more efficient since it does not need to execute or store a closure."}],"type":"paragraph"},{"level":2,"text":"Detailed Design","type":"heading","anchor":"Detailed-Design"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"AsyncCompactedSequence"},{"type":"text","text":" type from an effects standpoint works just like "},{"type":"codeVoice","code":"AsyncCompactMapSequence"},{"type":"text","text":". When the base asynchronous sequence throws, the iteration of "},{"type":"codeVoice","code":"AsyncCompactedSequence"},{"type":"text","text":" can throw. Likewise if the base does not throw then the iteration of "},{"type":"codeVoice","code":"AsyncCompactedSequence"},{"type":"text","text":" does not throw. This type is conditionally "},{"type":"codeVoice","code":"Sendable"},{"type":"text","text":" when the base, base element, and base iterator are `Sendable."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["public struct AsyncCompactedSequence<Base: AsyncSequence, Element>: AsyncSequence","  where Base.Element == Element? {","","  public struct Iterator: AsyncIteratorProtocol {","    public mutating func next() async rethrows -> Element?","  }","","  public func makeAsyncIterator() -> Iterator {","    Iterator(base.makeAsyncIterator())","  }","}","","extension AsyncCompactedSequence: Sendable ","  where ","    Base: Sendable, Base.Element: Sendable, ","    Base.AsyncIterator: Sendable { }","  ","extension AsyncCompactedSequence.Iterator: Sendable ","  where ","    Base: Sendable, Base.Element: Sendable, ","    Base.AsyncIterator: Sendable { }"]},{"level":2,"text":"Credits\/Inspiration","type":"heading","anchor":"CreditsInspiration"},{"inlineContent":[{"type":"text","text":"This transformation function is a direct analog to the synchronous version "},{"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-algorithms\/blob\/main\/Guides\/Compacted.md"}],"type":"paragraph"}],"kind":"content"}],"schemaVersion":{"minor":3,"patch":0,"major":0},"seeAlsoSections":[{"title":"Getting Started","anchor":"Getting-Started","identifiers":["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AdjacentPairs","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/BufferedBytes","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chain","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Channel","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chunked","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Collections","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/CombineLatest","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Debounce","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Effects","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Intersperse","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Joined","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Lazy","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Merge","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Reductions","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/RemoveDuplicates"],"generated":true}],"metadata":{"title":"Compacted","modules":[{"name":"AsyncAlgorithms"}],"roleHeading":"Article","role":"article"},"references":{"https://github.com/apple/swift-async-algorithms/blob/main/Tests/AsyncAlgorithmsTests/TestCompacted.swift":{"titleInlineContent":[{"text":"Tests","type":"text"}],"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestCompacted.swift","title":"Tests","url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestCompacted.swift","type":"link"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Joined":{"title":"Joined","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Joined","url":"\/documentation\/asyncalgorithms\/joined","abstract":[],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Merge":{"title":"Merge","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Merge","url":"\/documentation\/asyncalgorithms\/merge","abstract":[{"type":"text","text":"Merges two or more asynchronous sequences sharing the same element type into one singular asynchronous sequence."}],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Reductions":{"title":"Reductions","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Reductions","url":"\/documentation\/asyncalgorithms\/reductions","abstract":[],"kind":"article"},"https://github.com/phausler":{"titleInlineContent":[{"text":"Philippe Hausler","type":"text"}],"identifier":"https:\/\/github.com\/phausler","title":"Philippe Hausler","url":"https:\/\/github.com\/phausler","type":"link"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/CombineLatest":{"title":"Combine Latest","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/CombineLatest","url":"\/documentation\/asyncalgorithms\/combinelatest","abstract":[{"type":"text","text":"Combines the latest values produced from two or more asynchronous sequences into an asynchronous sequence of tuples."}],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/RemoveDuplicates":{"title":"RemoveDuplicates","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/RemoveDuplicates","url":"\/documentation\/asyncalgorithms\/removeduplicates","abstract":[],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Chain":{"title":"Chain","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chain","url":"\/documentation\/asyncalgorithms\/chain","abstract":[{"type":"text","text":"Chains two or more asynchronous sequences together sequentially."}],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Channel":{"title":"Channel","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Channel","url":"\/documentation\/asyncalgorithms\/channel","abstract":[],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Effects":{"title":"Effects","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Effects","url":"\/documentation\/asyncalgorithms\/effects","abstract":[{"type":"text","text":"Lists the effects of all async algorithms."}],"kind":"article"},"https://github.com/apple/swift-algorithms/blob/main/Guides/Compacted.md":{"titleInlineContent":[{"text":"defined in the Swift Algorithms package","type":"text"}],"identifier":"https:\/\/github.com\/apple\/swift-algorithms\/blob\/main\/Guides\/Compacted.md","title":"defined in the Swift Algorithms package","url":"https:\/\/github.com\/apple\/swift-algorithms\/blob\/main\/Guides\/Compacted.md","type":"link"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/BufferedBytes":{"title":"AsyncBufferedByteIterator","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/BufferedBytes","url":"\/documentation\/asyncalgorithms\/bufferedbytes","abstract":[{"type":"text","text":"Provides a highly efficient iterator useful for iterating byte sequences derived from asynchronous read functions."}],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Collections":{"title":"Collection Initializers","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Collections","url":"\/documentation\/asyncalgorithms\/collections","abstract":[],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Chunked":{"title":"Chunked","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chunked","url":"\/documentation\/asyncalgorithms\/chunked","abstract":[],"kind":"article"},"https://github.com/apple/swift-async-algorithms/blob/main/Sources/AsyncAlgorithms/AsyncCompactedSequence.swift":{"titleInlineContent":[{"text":"Source","type":"text"}],"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/AsyncCompactedSequence.swift","title":"Source","url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/AsyncCompactedSequence.swift","type":"link"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/AdjacentPairs":{"title":"AdjacentPairs","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AdjacentPairs","url":"\/documentation\/asyncalgorithms\/adjacentpairs","abstract":[],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Lazy":{"title":"AsyncSyncSequence","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Lazy","url":"\/documentation\/asyncalgorithms\/lazy","abstract":[{"type":"text","text":"This operation is available for all "},{"code":"Sequence","type":"codeVoice"},{"type":"text","text":" types."}],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Debounce":{"title":"Debounce","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Debounce","url":"\/documentation\/asyncalgorithms\/debounce","abstract":[],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Intersperse":{"title":"Intersperse","type":"topic","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Intersperse","url":"\/documentation\/asyncalgorithms\/intersperse","abstract":[{"type":"text","text":"Places a given value in between each element of the asynchronous sequence."}],"kind":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms":{"type":"topic","abstract":[{"type":"strong","inlineContent":[{"type":"text","text":"Swift Async Algorithms"}]},{"type":"text","text":" is an open-source package of asynchronous sequence and advanced algorithms that involve concurrency, along with their related types."}],"title":"AsyncAlgorithms","kind":"symbol","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms","role":"collection","url":"\/documentation\/asyncalgorithms"}}}