{"primaryContentSections":[{"kind":"content","content":[{"anchor":"overview","text":"Overview","type":"heading","level":2},{"items":[{"content":[{"inlineContent":[{"text":"Author(s): ","type":"text"},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/phausler"}],"type":"paragraph"}]}],"type":"unorderedList"},{"inlineContent":[{"text":"[","type":"text"},{"text":" ","type":"text"},{"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/AsyncCompactedSequence.swift","type":"reference","isActive":true},{"text":" |","type":"text"},{"text":" ","type":"text"},{"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestCompacted.swift","type":"reference","isActive":true},{"text":" ","type":"text"},{"text":"]","type":"text"}],"type":"paragraph"},{"anchor":"Introduction","text":"Introduction","type":"heading","level":2},{"inlineContent":[{"text":"Just as it is common for ","type":"text"},{"code":"Sequence","type":"codeVoice"},{"text":" types that contain optional values to need to ","type":"text"},{"code":".compactMap { $0 }","type":"codeVoice"},{"text":", ","type":"text"},{"code":"AsyncSequence","type":"codeVoice"},{"text":" types have the same use cases. This common task means that the type must employ a closure to test the optional value. This can be done more efficiently for both execution performance as well as API efficiency of typing.","type":"text"}],"type":"paragraph"},{"anchor":"Proposed-Solution","text":"Proposed Solution","type":"heading","level":2},{"inlineContent":[{"text":"Similar to the Swift Algorithms package we propose that a new method be added to ","type":"text"},{"type":"codeVoice","code":"AsyncSequence"},{"type":"text","text":" to fit this need."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["extension AsyncSequence {","  public func compacted<Unwrapped>() -> AsyncCompactedSequence<Self, Unwrapped>","    where Element == Unwrapped?","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is equivalent to writing "},{"type":"codeVoice","code":".compactMap { $0 }"},{"type":"text","text":" from a behavioral standpoint but is easier to reason about and is more efficient since it does not need to execute or store a closure."}]},{"type":"heading","level":2,"text":"Detailed Design","anchor":"Detailed-Design"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"AsyncCompactedSequence"},{"type":"text","text":" type from an effects standpoint works just like "},{"type":"codeVoice","code":"AsyncCompactMapSequence"},{"type":"text","text":". When the base asynchronous sequence throws, the iteration of "},{"type":"codeVoice","code":"AsyncCompactedSequence"},{"type":"text","text":" can throw. Likewise if the base does not throw then the iteration of "},{"type":"codeVoice","code":"AsyncCompactedSequence"},{"type":"text","text":" does not throw. This type is conditionally "},{"type":"codeVoice","code":"Sendable"},{"type":"text","text":" when the base, base element, and base iterator are `Sendable."}]},{"type":"codeListing","syntax":"swift","code":["public struct AsyncCompactedSequence<Base: AsyncSequence, Element>: AsyncSequence","  where Base.Element == Element? {","","  public struct Iterator: AsyncIteratorProtocol {","    public mutating func next() async rethrows -> Element?","  }","","  public func makeAsyncIterator() -> Iterator {","    Iterator(base.makeAsyncIterator())","  }","}","","extension AsyncCompactedSequence: Sendable ","  where ","    Base: Sendable, Base.Element: Sendable, ","    Base.AsyncIterator: Sendable { }","  ","extension AsyncCompactedSequence.Iterator: Sendable ","  where ","    Base: Sendable, Base.Element: Sendable, ","    Base.AsyncIterator: Sendable { }"]},{"type":"heading","level":2,"text":"Credits\/Inspiration","anchor":"CreditsInspiration"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This transformation function is a direct analog to the synchronous version "},{"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-algorithms\/blob\/main\/Guides\/Compacted.md","isActive":true}]}]}],"seeAlsoSections":[{"title":"Getting Started","identifiers":["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AdjacentPairs","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/BufferedBytes","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chain","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Channel","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chunked","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Collections","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/CombineLatest","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Debounce","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Effects","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Intersperse","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Joined","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Lazy","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Merge","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Reductions","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/RemoveDuplicates"],"generated":true,"anchor":"Getting-Started"}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Compacted"},"variants":[{"paths":["\/documentation\/asyncalgorithms\/compacted"],"traits":[{"interfaceLanguage":"swift"}]}],"hierarchy":{"paths":[["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms"]]},"kind":"article","sections":[],"metadata":{"title":"Compacted","modules":[{"name":"AsyncAlgorithms"}],"role":"article","roleHeading":"Article"},"schemaVersion":{"patch":0,"major":0,"minor":3},"references":{"https://github.com/apple/swift-algorithms/blob/main/Guides/Compacted.md":{"type":"link","title":"defined in the Swift Algorithms package","titleInlineContent":[{"text":"defined in the Swift Algorithms package","type":"text"}],"identifier":"https:\/\/github.com\/apple\/swift-algorithms\/blob\/main\/Guides\/Compacted.md","url":"https:\/\/github.com\/apple\/swift-algorithms\/blob\/main\/Guides\/Compacted.md"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms":{"type":"topic","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms","title":"AsyncAlgorithms","url":"\/documentation\/asyncalgorithms","kind":"symbol","abstract":[{"inlineContent":[{"type":"text","text":"Swift Async Algorithms"}],"type":"strong"},{"text":" is an open-source package of asynchronous sequence and advanced algorithms that involve concurrency, along with their related types.","type":"text"}],"role":"collection"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/BufferedBytes":{"title":"AsyncBufferedByteIterator","abstract":[{"type":"text","text":"Provides a highly efficient iterator useful for iterating byte sequences derived from asynchronous read functions."}],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/BufferedBytes","type":"topic","url":"\/documentation\/asyncalgorithms\/bufferedbytes","kind":"article","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Joined":{"title":"Joined","abstract":[],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Joined","type":"topic","url":"\/documentation\/asyncalgorithms\/joined","kind":"article","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/AdjacentPairs":{"title":"AdjacentPairs","type":"topic","url":"\/documentation\/asyncalgorithms\/adjacentpairs","kind":"article","role":"article","abstract":[],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AdjacentPairs"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Channel":{"title":"Channel","abstract":[],"url":"\/documentation\/asyncalgorithms\/channel","type":"topic","kind":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Channel","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/CombineLatest":{"title":"Combine Latest","type":"topic","url":"\/documentation\/asyncalgorithms\/combinelatest","kind":"article","role":"article","abstract":[{"type":"text","text":"Combines the latest values produced from two or more asynchronous sequences into an asynchronous sequence of tuples."}],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/CombineLatest"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Chain":{"title":"Chain","abstract":[{"type":"text","text":"Chains two or more asynchronous sequences together sequentially."}],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chain","type":"topic","url":"\/documentation\/asyncalgorithms\/chain","kind":"article","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Debounce":{"title":"Debounce","type":"topic","url":"\/documentation\/asyncalgorithms\/debounce","kind":"article","role":"article","abstract":[],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Debounce"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Reductions":{"url":"\/documentation\/asyncalgorithms\/reductions","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Reductions","kind":"article","abstract":[],"title":"Reductions","type":"topic","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Lazy":{"title":"AsyncSyncSequence","abstract":[{"text":"This operation is available for all ","type":"text"},{"code":"Sequence","type":"codeVoice"},{"text":" types.","type":"text"}],"url":"\/documentation\/asyncalgorithms\/lazy","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Lazy","type":"topic","kind":"article","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/RemoveDuplicates":{"title":"RemoveDuplicates","abstract":[],"url":"\/documentation\/asyncalgorithms\/removeduplicates","type":"topic","kind":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/RemoveDuplicates","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Intersperse":{"title":"Intersperse","abstract":[{"type":"text","text":"Places a given value in between each element of the asynchronous sequence."}],"url":"\/documentation\/asyncalgorithms\/intersperse","type":"topic","kind":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Intersperse","role":"article"},"https://github.com/phausler":{"titleInlineContent":[{"text":"Philippe Hausler","type":"text"}],"url":"https:\/\/github.com\/phausler","type":"link","title":"Philippe Hausler","identifier":"https:\/\/github.com\/phausler"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Chunked":{"title":"Chunked","type":"topic","url":"\/documentation\/asyncalgorithms\/chunked","kind":"article","role":"article","abstract":[],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chunked"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Effects":{"title":"Effects","abstract":[{"text":"Lists the effects of all async algorithms.","type":"text"}],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Effects","kind":"article","type":"topic","url":"\/documentation\/asyncalgorithms\/effects","role":"article"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Merge":{"title":"Merge","type":"topic","url":"\/documentation\/asyncalgorithms\/merge","kind":"article","role":"article","abstract":[{"text":"Merges two or more asynchronous sequences sharing the same element type into one singular asynchronous sequence.","type":"text"}],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Merge"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Collections":{"title":"Collection Initializers","type":"topic","url":"\/documentation\/asyncalgorithms\/collections","kind":"article","role":"article","abstract":[],"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Collections"},"https://github.com/apple/swift-async-algorithms/blob/main/Tests/AsyncAlgorithmsTests/TestCompacted.swift":{"titleInlineContent":[{"type":"text","text":"Tests"}],"title":"Tests","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestCompacted.swift","url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestCompacted.swift","type":"link"},"https://github.com/apple/swift-async-algorithms/blob/main/Sources/AsyncAlgorithms/AsyncCompactedSequence.swift":{"type":"link","title":"Source","titleInlineContent":[{"text":"Source","type":"text"}],"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/AsyncCompactedSequence.swift","url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/AsyncCompactedSequence.swift"}}}