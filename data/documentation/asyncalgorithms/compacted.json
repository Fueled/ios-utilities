{"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Compacted"},"sections":[],"metadata":{"title":"Compacted","roleHeading":"Article","modules":[{"name":"AsyncAlgorithms"}],"role":"article"},"variants":[{"paths":["\/documentation\/asyncalgorithms\/compacted"],"traits":[{"interfaceLanguage":"swift"}]}],"primaryContentSections":[{"kind":"content","content":[{"type":"heading","text":"Overview","anchor":"overview","level":2},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Author(s): ","type":"text"},{"identifier":"https:\/\/github.com\/phausler","isActive":true,"type":"reference"}]}]}]},{"type":"paragraph","inlineContent":[{"text":"[","type":"text"},{"text":" ","type":"text"},{"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/AsyncCompactedSequence.swift"},{"text":" |","type":"text"},{"text":" ","type":"text"},{"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestCompacted.swift"},{"text":" ","type":"text"},{"text":"]","type":"text"}]},{"type":"heading","text":"Introduction","anchor":"Introduction","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"Just as it is common for "},{"type":"codeVoice","code":"Sequence"},{"type":"text","text":" types that contain optional values to need to "},{"type":"codeVoice","code":".compactMap { $0 }"},{"type":"text","text":", "},{"type":"codeVoice","code":"AsyncSequence"},{"type":"text","text":" types have the same use cases. This common task means that the type must employ a closure to test the optional value. This can be done more efficiently for both execution performance as well as API efficiency of typing."}]},{"type":"heading","text":"Proposed Solution","anchor":"Proposed-Solution","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"Similar to the Swift Algorithms package we propose that a new method be added to "},{"code":"AsyncSequence","type":"codeVoice"},{"type":"text","text":" to fit this need."}]},{"type":"codeListing","code":["extension AsyncSequence {","  public func compacted<Unwrapped>() -> AsyncCompactedSequence<Self, Unwrapped>","    where Element == Unwrapped?","}"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"This is equivalent to writing "},{"type":"codeVoice","code":".compactMap { $0 }"},{"type":"text","text":" from a behavioral standpoint but is easier to reason about and is more efficient since it does not need to execute or store a closure."}],"type":"paragraph"},{"anchor":"Detailed-Design","level":2,"type":"heading","text":"Detailed Design"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"AsyncCompactedSequence"},{"type":"text","text":" type from an effects standpoint works just like "},{"type":"codeVoice","code":"AsyncCompactMapSequence"},{"type":"text","text":". When the base asynchronous sequence throws, the iteration of "},{"type":"codeVoice","code":"AsyncCompactedSequence"},{"type":"text","text":" can throw. Likewise if the base does not throw then the iteration of "},{"type":"codeVoice","code":"AsyncCompactedSequence"},{"type":"text","text":" does not throw. This type is conditionally "},{"type":"codeVoice","code":"Sendable"},{"type":"text","text":" when the base, base element, and base iterator are `Sendable."}],"type":"paragraph"},{"syntax":"swift","code":["public struct AsyncCompactedSequence<Base: AsyncSequence, Element>: AsyncSequence","  where Base.Element == Element? {","","  public struct Iterator: AsyncIteratorProtocol {","    public mutating func next() async rethrows -> Element?","  }","","  public func makeAsyncIterator() -> Iterator {","    Iterator(base.makeAsyncIterator())","  }","}","","extension AsyncCompactedSequence: Sendable ","  where ","    Base: Sendable, Base.Element: Sendable, ","    Base.AsyncIterator: Sendable { }","  ","extension AsyncCompactedSequence.Iterator: Sendable ","  where ","    Base: Sendable, Base.Element: Sendable, ","    Base.AsyncIterator: Sendable { }"],"type":"codeListing"},{"anchor":"CreditsInspiration","level":2,"type":"heading","text":"Credits\/Inspiration"},{"inlineContent":[{"type":"text","text":"This transformation function is a direct analog to the synchronous version "},{"identifier":"https:\/\/github.com\/apple\/swift-algorithms\/blob\/main\/Guides\/Compacted.md","type":"reference","isActive":true}],"type":"paragraph"}]}],"schemaVersion":{"minor":3,"patch":0,"major":0},"kind":"article","seeAlsoSections":[{"identifiers":["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AdjacentPairs","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/BufferedBytes","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chain","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Channel","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chunked","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Collections","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/CombineLatest","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Debounce","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Effects","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Intersperse","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Joined","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Lazy","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Merge","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Reductions","doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/RemoveDuplicates"],"title":"Getting Started","anchor":"Getting-Started","generated":true}],"hierarchy":{"paths":[["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms"]]},"references":{"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Collections":{"url":"\/documentation\/asyncalgorithms\/collections","type":"topic","title":"Collection Initializers","abstract":[],"kind":"article","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Collections"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Channel":{"url":"\/documentation\/asyncalgorithms\/channel","type":"topic","title":"Channel","abstract":[],"kind":"article","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Channel"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/CombineLatest":{"title":"Combine Latest","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/CombineLatest","kind":"article","url":"\/documentation\/asyncalgorithms\/combinelatest","role":"article","type":"topic","abstract":[{"type":"text","text":"Combines the latest values produced from two or more asynchronous sequences into an asynchronous sequence of tuples."}]},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Chunked":{"title":"Chunked","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chunked","kind":"article","url":"\/documentation\/asyncalgorithms\/chunked","role":"article","type":"topic","abstract":[]},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Lazy":{"title":"AsyncSyncSequence","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Lazy","kind":"article","url":"\/documentation\/asyncalgorithms\/lazy","role":"article","type":"topic","abstract":[{"type":"text","text":"This operation is available for all "},{"type":"codeVoice","code":"Sequence"},{"type":"text","text":" types."}]},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Merge":{"role":"article","abstract":[{"text":"Merges two or more asynchronous sequences sharing the same element type into one singular asynchronous sequence.","type":"text"}],"type":"topic","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Merge","url":"\/documentation\/asyncalgorithms\/merge","kind":"article","title":"Merge"},"https://github.com/phausler":{"identifier":"https:\/\/github.com\/phausler","titleInlineContent":[{"type":"text","text":"Philippe Hausler"}],"url":"https:\/\/github.com\/phausler","type":"link","title":"Philippe Hausler"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Intersperse":{"title":"Intersperse","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Intersperse","kind":"article","url":"\/documentation\/asyncalgorithms\/intersperse","role":"article","type":"topic","abstract":[{"type":"text","text":"Places a given value in between each element of the asynchronous sequence."}]},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Reductions":{"title":"Reductions","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Reductions","kind":"article","url":"\/documentation\/asyncalgorithms\/reductions","role":"article","type":"topic","abstract":[]},"https://github.com/apple/swift-async-algorithms/blob/main/Tests/AsyncAlgorithmsTests/TestCompacted.swift":{"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestCompacted.swift","titleInlineContent":[{"type":"text","text":"Tests"}],"type":"link","title":"Tests","url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Tests\/AsyncAlgorithmsTests\/TestCompacted.swift"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/AdjacentPairs":{"url":"\/documentation\/asyncalgorithms\/adjacentpairs","type":"topic","title":"AdjacentPairs","abstract":[],"kind":"article","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AdjacentPairs"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Chain":{"url":"\/documentation\/asyncalgorithms\/chain","type":"topic","title":"Chain","abstract":[{"text":"Chains two or more asynchronous sequences together sequentially.","type":"text"}],"kind":"article","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Chain"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms":{"identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms","kind":"symbol","role":"collection","url":"\/documentation\/asyncalgorithms","title":"AsyncAlgorithms","abstract":[{"type":"strong","inlineContent":[{"text":"Swift Async Algorithms","type":"text"}]},{"type":"text","text":" is an open-source package of asynchronous sequence and advanced algorithms that involve concurrency, along with their related types."}],"type":"topic"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/BufferedBytes":{"title":"AsyncBufferedByteIterator","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/BufferedBytes","kind":"article","url":"\/documentation\/asyncalgorithms\/bufferedbytes","role":"article","type":"topic","abstract":[{"type":"text","text":"Provides a highly efficient iterator useful for iterating byte sequences derived from asynchronous read functions."}]},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Effects":{"url":"\/documentation\/asyncalgorithms\/effects","type":"topic","title":"Effects","abstract":[{"text":"Lists the effects of all async algorithms.","type":"text"}],"kind":"article","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Effects"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/RemoveDuplicates":{"url":"\/documentation\/asyncalgorithms\/removeduplicates","type":"topic","title":"RemoveDuplicates","abstract":[],"kind":"article","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/RemoveDuplicates"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Joined":{"title":"Joined","url":"\/documentation\/asyncalgorithms\/joined","type":"topic","abstract":[],"kind":"article","role":"article","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Joined"},"https://github.com/apple/swift-algorithms/blob/main/Guides/Compacted.md":{"type":"link","identifier":"https:\/\/github.com\/apple\/swift-algorithms\/blob\/main\/Guides\/Compacted.md","title":"defined in the Swift Algorithms package","titleInlineContent":[{"type":"text","text":"defined in the Swift Algorithms package"}],"url":"https:\/\/github.com\/apple\/swift-algorithms\/blob\/main\/Guides\/Compacted.md"},"https://github.com/apple/swift-async-algorithms/blob/main/Sources/AsyncAlgorithms/AsyncCompactedSequence.swift":{"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/AsyncCompactedSequence.swift","titleInlineContent":[{"type":"text","text":"Source"}],"url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/main\/Sources\/AsyncAlgorithms\/AsyncCompactedSequence.swift","type":"link","title":"Source"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/Debounce":{"title":"Debounce","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/Debounce","kind":"article","url":"\/documentation\/asyncalgorithms\/debounce","role":"article","type":"topic","abstract":[]}}}