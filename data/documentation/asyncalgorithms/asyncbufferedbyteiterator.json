{"schemaVersion":{"major":0,"patch":0,"minor":3},"hierarchy":{"paths":[["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms"]]},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/asyncalgorithms\/asyncbufferedbyteiterator"]}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AsyncBufferedByteIterator"},"sections":[],"topicSections":[{"title":"Initializers","anchor":"Initializers","identifiers":["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AsyncBufferedByteIterator\/init(capacity:readFunction:)"],"generated":true},{"title":"Instance Methods","anchor":"Instance-Methods","identifiers":["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AsyncBufferedByteIterator\/next()"],"generated":true},{"title":"Type Aliases","anchor":"Type-Aliases","identifiers":["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AsyncBufferedByteIterator\/Element"],"generated":true},{"title":"Default Implementations","anchor":"Default-Implementations","identifiers":["doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AsyncBufferedByteIterator\/AsyncIteratorProtocol-Implementations"],"generated":true}],"metadata":{"modules":[{"name":"AsyncAlgorithms"}],"title":"AsyncBufferedByteIterator","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"AsyncBufferedByteIterator"}],"role":"symbol","navigatorTitle":[{"kind":"identifier","text":"AsyncBufferedByteIterator"}],"externalID":"s:15AsyncAlgorithms0A20BufferedByteIteratorV","symbolKind":"struct","platforms":[{"deprecated":false,"beta":false,"unavailable":false,"name":"iOS","introducedAt":"13.0"},{"deprecated":false,"beta":false,"unavailable":false,"name":"macOS","introducedAt":"10.15"},{"deprecated":false,"beta":false,"unavailable":false,"name":"tvOS","introducedAt":"13.0"},{"deprecated":false,"beta":false,"unavailable":false,"name":"watchOS","introducedAt":"6.0"}],"roleHeading":"Structure"},"relationshipsSections":[{"title":"Conforms To","type":"conformsTo","identifiers":["doc:\/\/AsyncAlgorithms\/ScI"],"kind":"relationships"}],"abstract":[{"type":"text","text":"An "},{"code":"AsyncIterator","type":"codeVoice"},{"type":"text","text":" that provides a convenient and high-performance implementation"},{"type":"text","text":" "},{"type":"text","text":"of a common architecture for "},{"code":"AsyncSequence","type":"codeVoice"},{"type":"text","text":" of "},{"code":"UInt8","type":"codeVoice"},{"type":"text","text":", otherwise known as byte streams."}],"primaryContentSections":[{"declarations":[{"platforms":["macOS"],"languages":["swift"],"tokens":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"AsyncBufferedByteIterator"}]}],"kind":"declarations"},{"content":[{"type":"heading","anchor":"overview","level":2,"text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Bytes are read into an internal buffer of "},{"type":"codeVoice","code":"capacity"},{"type":"text","text":" bytes via the"},{"type":"text","text":" "},{"type":"codeVoice","code":"readFunction"},{"type":"text","text":". Invoking "},{"type":"codeVoice","code":"next()"},{"type":"text","text":" returns bytes from the internal buffer until itâ€™s"},{"type":"text","text":" "},{"type":"text","text":"empty, and then suspends and awaits another invocation of "},{"type":"codeVoice","code":"readFunction"},{"type":"text","text":" to"},{"type":"text","text":" "},{"type":"text","text":"refill. If "},{"type":"codeVoice","code":"readFunction"},{"type":"text","text":" returns 0 (indicating nothing was read), "},{"type":"codeVoice","code":"next()"},{"type":"text","text":" will"},{"type":"text","text":" "},{"type":"text","text":"return "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" from then on. Cancellation is checked before each invocation of"},{"type":"text","text":" "},{"type":"codeVoice","code":"readFunction"},{"type":"text","text":", which means that many calls to "},{"type":"codeVoice","code":"next()"},{"type":"text","text":" will not check for"},{"type":"text","text":" "},{"type":"text","text":"cancellation."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A typical use of "},{"type":"codeVoice","code":"AsyncBufferedByteIterator"},{"type":"text","text":" looks something like this:"}]},{"code":["struct AsyncBytes: AsyncSequence {","  public typealias Element = UInt8","  var handle: ReadableThing","","  internal init(_ readable: ReadableThing) {","    handle = readable","  }","","  public func makeAsyncIterator() -> AsyncBufferedByteIterator {","    return AsyncBufferedByteIterator(capacity: 16384) { buffer in","      \/\/ This runs once every 16384 invocations of next()","      return try await handle.read(into: buffer)","    }","  }","}"],"type":"codeListing","syntax":null}],"kind":"content"}],"kind":"symbol","references":{"doc://AsyncAlgorithms/documentation/AsyncAlgorithms":{"type":"topic","abstract":[{"type":"strong","inlineContent":[{"type":"text","text":"Swift Async Algorithms"}]},{"type":"text","text":" is an open-source package of asynchronous sequence and advanced algorithms that involve concurrency, along with their related types."}],"title":"AsyncAlgorithms","kind":"symbol","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms","role":"collection","url":"\/documentation\/asyncalgorithms"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/AsyncBufferedByteIterator":{"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"AsyncBufferedByteIterator"}],"title":"AsyncBufferedByteIterator","type":"topic","role":"symbol","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AsyncBufferedByteIterator","navigatorTitle":[{"kind":"identifier","text":"AsyncBufferedByteIterator"}],"url":"\/documentation\/asyncalgorithms\/asyncbufferedbyteiterator","abstract":[{"type":"text","text":"An "},{"code":"AsyncIterator","type":"codeVoice"},{"type":"text","text":" that provides a convenient and high-performance implementation"},{"type":"text","text":" "},{"type":"text","text":"of a common architecture for "},{"code":"AsyncSequence","type":"codeVoice"},{"type":"text","text":" of "},{"code":"UInt8","type":"codeVoice"},{"type":"text","text":", otherwise known as byte streams."}],"kind":"symbol"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/AsyncBufferedByteIterator/Element":{"fragments":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"kind":"identifier","text":"Element"}],"title":"AsyncBufferedByteIterator.Element","type":"topic","role":"symbol","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AsyncBufferedByteIterator\/Element","navigatorTitle":[{"kind":"identifier","text":"Element"}],"url":"\/documentation\/asyncalgorithms\/asyncbufferedbyteiterator\/element","abstract":[],"kind":"symbol"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/AsyncBufferedByteIterator/init(capacity:readFunction:)":{"fragments":[{"text":"init","kind":"identifier"},{"text":"(","kind":"text"},{"text":"capacity","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"Int","preciseIdentifier":"s:Si","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"text":"readFunction","kind":"externalParam"},{"text":": (","kind":"text"},{"text":"UnsafeMutableRawBufferPointer","preciseIdentifier":"s:Sw","kind":"typeIdentifier"},{"text":") ","kind":"text"},{"text":"async","kind":"keyword"},{"text":" ","kind":"text"},{"text":"throws","kind":"keyword"},{"text":" -> ","kind":"text"},{"text":"Int","preciseIdentifier":"s:Si","kind":"typeIdentifier"},{"text":")","kind":"text"}],"title":"init(capacity:readFunction:)","type":"topic","role":"symbol","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AsyncBufferedByteIterator\/init(capacity:readFunction:)","url":"\/documentation\/asyncalgorithms\/asyncbufferedbyteiterator\/init(capacity:readfunction:)","abstract":[{"type":"text","text":"Creates an asynchronous buffered byte iterator with a specified capacity and read function."}],"kind":"symbol"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/AsyncBufferedByteIterator/next()":{"fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"next","kind":"identifier"},{"text":"() ","kind":"text"},{"text":"async","kind":"keyword"},{"text":" ","kind":"text"},{"text":"throws","kind":"keyword"},{"text":" -> ","kind":"text"},{"text":"UInt8","preciseIdentifier":"s:s5UInt8V","kind":"typeIdentifier"},{"text":"?","kind":"text"}],"title":"next()","type":"topic","role":"symbol","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AsyncBufferedByteIterator\/next()","url":"\/documentation\/asyncalgorithms\/asyncbufferedbyteiterator\/next()","abstract":[{"type":"text","text":"Reads a byte out of the buffer if available. When no bytes are available, this will trigger"},{"type":"text","text":" "},{"type":"text","text":"the read function to reload the buffer and then return the next byte from that buffer."}],"kind":"symbol"},"doc://AsyncAlgorithms/documentation/AsyncAlgorithms/AsyncBufferedByteIterator/AsyncIteratorProtocol-Implementations":{"title":"AsyncIteratorProtocol Implementations","type":"topic","role":"collectionGroup","identifier":"doc:\/\/AsyncAlgorithms\/documentation\/AsyncAlgorithms\/AsyncBufferedByteIterator\/AsyncIteratorProtocol-Implementations","url":"\/documentation\/asyncalgorithms\/asyncbufferedbyteiterator\/asynciteratorprotocol-implementations","abstract":[],"kind":"article"},"doc://AsyncAlgorithms/ScI":{"title":"_Concurrency.AsyncIteratorProtocol","identifier":"doc:\/\/AsyncAlgorithms\/ScI","type":"unresolvable"}}}