{"identifier":{"url":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/ReliablyTestingAsync","interfaceLanguage":"swift"},"schemaVersion":{"minor":3,"major":0,"patch":0},"metadata":{"role":"article","roleHeading":"Article","title":"Reliably testing async code","modules":[{"name":"ConcurrencyExtras"}]},"abstract":[{"type":"text","text":"Learn how to use the tools of this library to write reliable, deterministic tests for your async"},{"type":"text","text":" "},{"type":"text","text":"Swift code."}],"kind":"article","sections":[],"hierarchy":{"paths":[["doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras"]]},"variants":[{"paths":["\/documentation\/concurrencyextras\/reliablytestingasync"],"traits":[{"interfaceLanguage":"swift"}]}],"primaryContentSections":[{"kind":"content","content":[{"type":"heading","level":2,"text":"Overview","anchor":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift 5.5 brought first class support for concurrency to the language, including lightweight syntax"},{"type":"text","text":" "},{"type":"text","text":"for describing when functions and methods need to perform async work, a new data type for"},{"type":"text","text":" "},{"type":"text","text":"isolating mutable data, and all new APIs for performing non-blocking asynchronous work. This made it"},{"type":"text","text":" "},{"type":"text","text":"far easier to write async code than ever before, but it also made testing asynchronous code quite"},{"type":"text","text":" "},{"type":"text","text":"a bit more complicated."}]},{"inlineContent":[{"type":"text","text":"Join us for a quick overview of what tools Swift gives us today for testing asynchronous code, as"},{"type":"text","text":" "},{"type":"text","text":"well as examples of how these tools can fall short, and then how to fix them."}],"type":"paragraph"},{"style":"note","content":[{"inlineContent":[{"type":"text","text":"This article is a brief recap of a "},{"type":"reference","identifier":"https:\/\/www.pointfree.co\/collections\/concurrency\/testing-async-code","isActive":true},{"type":"text","text":" on Point-Free that"},{"type":"text","text":" "},{"type":"text","text":"goes very deep into how to reliably test async code in Swift."}],"type":"paragraph"}],"type":"aside","name":"Note"},{"anchor":"Async-testing-tools-of-today","type":"heading","level":2,"text":"Async testing tools of today"},{"inlineContent":[{"type":"text","text":"The primary tool for testing async code today is XCTest’s support for async test cases. Simply mark"},{"type":"text","text":" "},{"type":"text","text":"your test method as "},{"type":"codeVoice","code":"async"},{"type":"text","text":" and then you are free to perform any async work you want:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["class FeatureTests: XCTestCase {","  func testBasics() async {","    …","  }","}"]},{"inlineContent":[{"type":"text","text":"This makes it easy to invoke an async function or method and then assert on what changed after"},{"type":"text","text":" "},{"type":"text","text":"the work finished."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"For example, suppose we had a very simple observable object for encapsulating a number that could"},{"type":"text","text":" "},{"type":"text","text":"be incremented and decremented from the UI, as well as the ability to fetch a fact about the"},{"type":"text","text":" "},{"type":"text","text":"number. The mechanism for fetching the fact should be hidden behind some kind of interface, like"},{"type":"text","text":" "},{"type":"text","text":"a protocol, but for now we will pass it as an explicit closure to the model."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Further, to make things interesting, we will also manage a piece of boolean state that tracks"},{"type":"text","text":" "},{"type":"text","text":"whether or not the fact is currently loading so that we can display a progress indicator in the"},{"type":"text","text":" "},{"type":"text","text":"view:"}],"type":"paragraph"},{"code":["@MainActor","@Observable","class FeatureModel {","  var count = 0","  var fact: String?","  var isLoadingFact = false","  ","  \/\/ NB: Can hide this closure behind an interface and use some sort of dependency","  \/\/ injection to provide it.","  let numberFact: (Int) async throws -> String","  init(numberFact: @escaping (Int) async throws -> String) {","    self.numberFact = numberFact","  }","  ","  func getFactButtonTapped() async {","    self.isLoadingFact = true ","    defer { self.isLoadingFact = false }","","    do {","      self.fact = try await self.numberFact(self.count)","    } catch {","      \/\/ TODO: Handle error","    } ","  }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"This model seems simple enough, yet it can be surprisingly tricky to test all aspects of it."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The easiest part of the model to test is that the "},{"type":"codeVoice","code":"fact"},{"type":"text","text":" state is populated eventually after the"},{"type":"text","text":" "},{"type":"text","text":"“Get fact” button is tapped. That can be done simply thanks to the support for async in tests, and"},{"type":"text","text":" "},{"type":"text","text":"by using some kind of “mock” version of the number fact closure that returns a response immediately"},{"type":"text","text":" "},{"type":"text","text":"rather than making a network request:"}],"type":"paragraph"},{"code":["@MainActor","func testGetFact() async {","  let model = FeatureModel(numberFact: { number in ","    \"\\(number) is a good number!\" ","  })","  ","  await model.getFactButtonTapped()","  XCAssertEqual(model.fact, \"0 is a good number!\")","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"This test will pass 100% of the time, and do so very quickly. And that’s great!"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"What’s not so great is that it’s not really possible to test that the "},{"type":"codeVoice","code":"isLoadingFact"},{"type":"text","text":" state flips"},{"type":"text","text":" "},{"type":"text","text":"from "},{"type":"codeVoice","code":"false"},{"type":"text","text":" to "},{"type":"codeVoice","code":"true"},{"type":"text","text":" and then back to "},{"type":"codeVoice","code":"false"},{"type":"text","text":". At least when using the tools that Swift gives us"},{"type":"text","text":" "},{"type":"text","text":"today for testing async code."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"First of all, naively asserting on "},{"type":"codeVoice","code":"isLoadingFact"},{"type":"text","text":" right after invoking "},{"type":"codeVoice","code":"getFactButtonTapped"},{"type":"text","text":" can’t"},{"type":"text","text":" "},{"type":"text","text":"possibly work because the async work has already finished by that point:"}],"type":"paragraph"},{"code":["await model.getFactButtonTapped()","XCTAssertEqual(model.isLoadingFact, true)  \/\/ ❌","XCAssertEqual(model.fact, \"0 is a good number!\")","XCTAssertEqual(model.isLoadingFact, false)"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"So what we need to do is run "},{"type":"codeVoice","code":"getFactButtonTapped"},{"type":"text","text":" in an unstructured "},{"type":"codeVoice","code":"Task"},{"type":"text","text":" so that it can run"},{"type":"text","text":" "},{"type":"text","text":"in parallel with the rest of the test. That should allow us to wiggle ourselves in between the"},{"type":"text","text":" "},{"type":"text","text":"moment the boolean state flips to "},{"type":"codeVoice","code":"true"},{"type":"text","text":" and then "},{"type":"codeVoice","code":"false"},{"type":"text","text":":"}],"type":"paragraph"},{"code":["let task = Task { await model.getFactButtonTapped() }","XCTAssertEqual(model.isLoadingFact, true)  \/\/ ❌","await task.value","XCAssertEqual(model.fact, \"0 is a good number!\")","XCTAssertEqual(model.isLoadingFact, false)"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"However this fails the vast majority of times. Over 99% of the time. It seems that "},{"inlineContent":[{"type":"text","text":"every"}],"type":"emphasis"},{"type":"text","text":" once in"},{"type":"text","text":" "},{"type":"text","text":"awhile the "},{"type":"codeVoice","code":"Task"},{"type":"text","text":" starts up fast enough to flip the boolean to "},{"type":"codeVoice","code":"true"},{"type":"text","text":", but that is a rare exception"},{"type":"text","text":" "},{"type":"text","text":"rather than the rule."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"What we really need to do is wait a "},{"inlineContent":[{"type":"text","text":"little"}],"type":"emphasis"},{"type":"text","text":" bit of time for the "},{"type":"codeVoice","code":"Task"},{"type":"text","text":" to start executing its code,"},{"type":"text","text":" "},{"type":"text","text":"but not "},{"inlineContent":[{"type":"text","text":"too"}],"type":"emphasis"},{"type":"text","text":" much time so that it finishes. Perhaps a single "},{"type":"codeVoice","code":"Task.yield"},{"type":"text","text":" will help:"}],"type":"paragraph"},{"code":["let task = Task { await model.getFactButtonTapped() }","await Task.yield()","XCTAssertEqual(model.isLoadingFact, true)  \/\/ ❌","await task.value","XCAssertEqual(model.fact, \"0 is a good number!\")","XCTAssertEqual(model.isLoadingFact, false)"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"Unfortunately this fails too, and it does so the vast majority of the time."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"And this is only one small example of async code that is difficult to test. If your async code"},{"type":"text","text":" "},{"type":"text","text":"tries to implement cancellation, or makes use of time-based asynchrony (such as clocks), or"},{"type":"text","text":" "},{"type":"text","text":"uses async sequences, or any number of things, then you will come across similar test failures that"},{"type":"text","text":" "},{"type":"text","text":"are essentially impossible to fix. You may be able to even get the tests to seemingly pass"},{"type":"text","text":" "},{"type":"text","text":"consistently, but almost always if you run them enough times (thousands or millions of times), you"},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"will"}],"type":"emphasis"},{"type":"text","text":" eventually get a test failure, and that breeds uncertainty in your test suite."}],"type":"paragraph"},{"anchor":"Looking-to-Async-Algorithms-for-inspiration","type":"heading","level":2,"text":"Looking to Async Algorithms for inspiration"},{"inlineContent":[{"type":"text","text":"So, what are we to do?"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The problem with testing this kind of async code in Swift is that we have no way to predict how"},{"type":"text","text":" "},{"type":"text","text":"the runtime will schedule and execute work. And that is fine when running the code in production,"},{"type":"text","text":" "},{"type":"text","text":"but we don’t need that complexity for tests. Most tests are verifying a very simple state machine"},{"type":"text","text":" "},{"type":"text","text":"of actions: the user performs a few actions, one after another, and we assert at each step of the"},{"type":"text","text":" "},{"type":"text","text":"way how the state of our feature changes."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"In such situations we don’t need the full power of a complex scheduling machine that manages a small"},{"type":"text","text":" "},{"type":"text","text":"pool of threads. It would be completely sufficient to serialize all async work to a single thread."},{"type":"text","text":" "},{"type":"text","text":"That does not mean that multiple concurrent tasks are not able to interleave. Suspension of async"},{"type":"text","text":" "},{"type":"text","text":"tasks can still work as you expect, but all actual work is run serially on a single thread."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"And interestingly, there is even a precendent for this in one of Apple’s open source Swift"},{"type":"text","text":" "},{"type":"text","text":"libraries! The "},{"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms","type":"reference","isActive":true},{"type":"text","text":" package comes with an"},{"type":"text","text":" "},{"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/tree\/07a0c1ee08e90dd15b05d45a3ead10929c0b7ec5\/Sources\/AsyncSequenceValidation","type":"reference","isActive":true},{"type":"text","text":" library with tools specifically designed"},{"type":"text","text":" "},{"type":"text","text":"to make testing async code a deterministic process. It needs this tool in order to write reliable,"},{"type":"text","text":" "},{"type":"text","text":"deterministic tests for its various operators, such as "},{"type":"codeVoice","code":"debounce"},{"type":"text","text":", "},{"type":"codeVoice","code":"throttle"},{"type":"text","text":", and more."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The way it accomplishes this is by "},{"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/07a0c1ee08e90dd15b05d45a3ead10929c0b7ec5\/Sources\/AsyncSequenceValidation\/Test.swift#L319-L321","type":"reference","isActive":true},{"type":"text","text":""},{"type":"text","text":" "},{"type":"text","text":"that Swift uses when new asynchronous tasks are created. And that hook is publicly exposed to us"},{"type":"text","text":" "},{"type":"text","text":"from Swift’s actual C++ codebase, which we can see by looking at its "},{"identifier":"https:\/\/github.com\/apple\/swift\/blob\/e89de6e7e0952c3d0485cc07129ec17f2763c12f\/include\/swift\/Runtime\/Concurrency.h#L734-L738","type":"reference","isActive":true},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"The async algorithms package uses that global hook to serialize all async work to a single queue"},{"type":"text","text":" "},{"type":"text","text":"rather than let the test be susceptible to the vagaries of the global concurrent executor, allowing"},{"type":"text","text":" "},{"type":"text","text":"it to write tests that pass deterministically, 100% of the time."}],"type":"paragraph"},{"anchor":"How-to-test-async-code-reliably","type":"heading","level":2,"text":"How to test async code reliably?"},{"inlineContent":[{"type":"text","text":"And so if Apple can write tests like this, why can’t we?"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Well, now we can thanks to the "},{"type":"codeVoice","code":"withMainSerialExecutor(operation:)-79jpc"},{"type":"text","text":" tool that ships with"},{"type":"text","text":" "},{"type":"text","text":"this library. It temporarily alters the manner in which Swift enqueues asynchronous work in order"},{"type":"text","text":" "},{"type":"text","text":"to serialize it to the main thread. This allows you to test every facet of the async code, including"},{"type":"text","text":" "},{"type":"text","text":"what happens between each suspension point, in a manner that is 100% deterministic."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"For example, the previous test we wrote, which passed sometimes but failed most of the times, can"},{"type":"text","text":" "},{"type":"text","text":"now be written in a way that passes 100% of the time:"}],"type":"paragraph"},{"code":["func testGetFact() async {","  await withMainSerialExecutor {","    let model = FeatureModel(numberFact: { number in","      await Task.yield()","      return \"\\(number) is a good number!\" ","    })","    ","    let task = Task { await model.getFactButtonTapped() }","    await Task.yield()","    XCTAssertEqual(model.isLoadingFact, true)  \/\/ ✅","    await task.value","    XCAssertEqual(model.fact, \"0 is a good number!\")  \/\/ ✅","    XCTAssertEqual(model.isLoadingFact, false)  \/\/ ✅","  }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"Because all enqueueing of work has been serialized we can be guaranteed that when we"},{"type":"text","text":" "},{"code":"await Task.yield()","type":"codeVoice"},{"type":"text","text":" in the test, all work that is suspended will have an opportunity to execute"},{"text":" ","type":"text"},{"text":"before execution is returned to our test. This means this test is guaranteed to always pass.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"You can even override the "},{"code":"invokeTest","type":"codeVoice"},{"type":"text","text":" method in your test case to force every test to run on the"},{"type":"text","text":" "},{"type":"text","text":"main serial executor:"}],"type":"paragraph"},{"code":["override func invokeTest() {","  withMainSerialExecutor {","    super.invokeTest()","  }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"This tool allows you to finally write tests against complex and subtle async code that you can be"},{"type":"text","text":" "},{"type":"text","text":"confident in. No more seeing mysterious test failures on CI and wasting hours of CI time re-running"},{"type":"text","text":" "},{"type":"text","text":"tests or hours of developer time investigating if they are true errors or simply flakiness in the"},{"type":"text","text":" "},{"type":"text","text":"async scheduling."}],"type":"paragraph"},{"anchor":"Testing-reality","type":"heading","level":2,"text":"Testing reality"},{"inlineContent":[{"text":"Note that by using ","type":"text"},{"type":"codeVoice","code":"withMainSerialExecutor(operation:)-79jpc"},{"type":"text","text":" you are technically making your"},{"type":"text","text":" "},{"type":"text","text":"tests behave in a manner that is different from how they would run in production. However, many"},{"type":"text","text":" "},{"type":"text","text":"tests written on a day-to-day basis do not invoke the full-blown vagaries of concurrency. Instead,"},{"type":"text","text":" "},{"type":"text","text":"tests often want to assert that when some user action happens, an async unit of work is executed,"},{"type":"text","text":" "},{"type":"text","text":"and that causes some state to change. Such tests should be written in a way that is 100%"},{"type":"text","text":" "},{"type":"text","text":"deterministic. And even Apple agrees in their "},{"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/07a0c1ee08e90dd15b05d45a3ead10929c0b7ec5\/Sources\/AsyncSequenceValidation\/AsyncSequenceValidation.docc\/AsyncSequenceValidation.md","isActive":true},{"type":"text","text":" where they justify why they think their manner of"},{"type":"text","text":" "},{"type":"text","text":"testing async sequences truly does test reality even though they are altering the runtime that"},{"type":"text","text":" "},{"type":"text","text":"schedules async work (emphasis ours):"}],"type":"paragraph"},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""},{"inlineContent":[{"text":"Testing is a critical area of focus for any package to make it","type":"text"},{"text":" ","type":"text"},{"text":"robust, catch bugs, and explain the expected behaviors in a documented manner. Testing things that","type":"text"},{"text":" ","type":"text"},{"text":"are asynchronous can be difficult, testing things that are asynchronous multiple times can be even","type":"text"},{"text":" ","type":"text"},{"text":"more difficult.","type":"text"}],"type":"emphasis"}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Types that implement AsyncSequence ","type":"text"},{"type":"strong","inlineContent":[{"type":"text","text":"can often be described in deterministic actions given"},{"type":"text","text":" "},{"text":"particular inputs","type":"text"}]},{"type":"text","text":". For the inputs, the events can be described as a discrete set: values, errors"},{"type":"text","text":" "},{"type":"text","text":"being thrown, the terminal state of returning a nil value from the iterator, or advancing in time"},{"type":"text","text":" "},{"type":"text","text":"and not doing anything. Likewise, the expected output has a discrete set of events: values, errors"},{"type":"text","text":" "},{"type":"text","text":"being caught, the terminal state of receiving a nil value from the iterator, or advancing in time"},{"type":"text","text":" "},{"type":"text","text":"and not doing anything."}],"type":"emphasis"}]}],"type":"aside","name":"Quote from AsyncAlgorithms"},{"inlineContent":[{"type":"text","text":"Just as async sequences can often be described with a determinstic sequences of inputs that lead to"},{"text":" ","type":"text"},{"text":"a deterministic sequence of outputs, the same is true of user actions in an application. And so we","type":"text"},{"text":" ","type":"text"},{"text":"too feel that many of the tests we write on a daily basis can be run inside","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"withMainSerialExecutor(operation:)-79jpc"},{"type":"text","text":" and that we are not weakening the strength of those"},{"type":"text","text":" "},{"type":"text","text":"tests in the least."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, if your code has truly complex asynchronous and concurrent operations, then it may be handy"},{"type":"text","text":" "},{"type":"text","text":"to write two sets of tests: one set that targets the main executor (using "},{"code":"withMainSerialExecutor(operation:)-79jpc","type":"codeVoice"},{"type":"text","text":")"},{"type":"text","text":" "},{"type":"text","text":"so that you can deterministically assert how the core system behaves, and then another set that"},{"type":"text","text":" "},{"type":"text","text":"targets the default, global executor. The latter tests will probably need to make weaker assertions"},{"type":"text","text":" "},{"type":"text","text":"due to non-determinism, but can still assert on some things."}]}]}],"references":{"https://github.com/apple/swift-async-algorithms/blob/07a0c1ee08e90dd15b05d45a3ead10929c0b7ec5/Sources/AsyncSequenceValidation/Test.swift#L319-L321":{"url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/07a0c1ee08e90dd15b05d45a3ead10929c0b7ec5\/Sources\/AsyncSequenceValidation\/Test.swift#L319-L321","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/07a0c1ee08e90dd15b05d45a3ead10929c0b7ec5\/Sources\/AsyncSequenceValidation\/Test.swift#L319-L321","type":"link","titleInlineContent":[{"type":"text","text":"overriding the global enqueue hook"}],"title":"overriding the global enqueue hook"},"https://github.com/apple/swift/blob/e89de6e7e0952c3d0485cc07129ec17f2763c12f/include/swift/Runtime/Concurrency.h#L734-L738":{"url":"https:\/\/github.com\/apple\/swift\/blob\/e89de6e7e0952c3d0485cc07129ec17f2763c12f\/include\/swift\/Runtime\/Concurrency.h#L734-L738","identifier":"https:\/\/github.com\/apple\/swift\/blob\/e89de6e7e0952c3d0485cc07129ec17f2763c12f\/include\/swift\/Runtime\/Concurrency.h#L734-L738","type":"link","titleInlineContent":[{"type":"text","text":"headers"}],"title":"headers"},"https://www.pointfree.co/collections/concurrency/testing-async-code":{"url":"https:\/\/www.pointfree.co\/collections\/concurrency\/testing-async-code","identifier":"https:\/\/www.pointfree.co\/collections\/concurrency\/testing-async-code","type":"link","titleInlineContent":[{"type":"text","text":"series of"},{"type":"text","text":" "},{"type":"text","text":"episodes"}],"title":"series of episodes"},"https://github.com/apple/swift-async-algorithms":{"url":"https:\/\/github.com\/apple\/swift-async-algorithms","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms","type":"link","titleInlineContent":[{"type":"text","text":"Async Algorithms"}],"title":"Async Algorithms"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras":{"url":"\/documentation\/concurrencyextras","kind":"symbol","role":"collection","type":"topic","abstract":[{"type":"text","text":"Useful, testable Swift concurrency."}],"identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras","title":"ConcurrencyExtras"},"https://github.com/apple/swift-async-algorithms/blob/07a0c1ee08e90dd15b05d45a3ead10929c0b7ec5/Sources/AsyncSequenceValidation/AsyncSequenceValidation.docc/AsyncSequenceValidation.md":{"url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/07a0c1ee08e90dd15b05d45a3ead10929c0b7ec5\/Sources\/AsyncSequenceValidation\/AsyncSequenceValidation.docc\/AsyncSequenceValidation.md","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/07a0c1ee08e90dd15b05d45a3ead10929c0b7ec5\/Sources\/AsyncSequenceValidation\/AsyncSequenceValidation.docc\/AsyncSequenceValidation.md","type":"link","titleInlineContent":[{"type":"text","text":"documentation of"},{"type":"text","text":" "},{"code":"AsyncSequenceValidation","type":"codeVoice"}],"title":"documentation of AsyncSequenceValidation"},"https://github.com/apple/swift-async-algorithms/tree/07a0c1ee08e90dd15b05d45a3ead10929c0b7ec5/Sources/AsyncSequenceValidation":{"url":"https:\/\/github.com\/apple\/swift-async-algorithms\/tree\/07a0c1ee08e90dd15b05d45a3ead10929c0b7ec5\/Sources\/AsyncSequenceValidation","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/tree\/07a0c1ee08e90dd15b05d45a3ead10929c0b7ec5\/Sources\/AsyncSequenceValidation","type":"link","titleInlineContent":[{"code":"AsyncSequenceValidation","type":"codeVoice"}],"title":"AsyncSequenceValidation"}}}