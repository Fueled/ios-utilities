// Copyright © 2020 Fueled Digital Media, LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#if canImport(Combine)
import Combine

///
/// Similar to `Action`, except if the action is already executing, subsequent `apply()` call will not fail,
/// and will be interrupt the previous apply().
///
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public class OverridingAction<Input, Output, Failure: Swift.Error>: ActionProtocol {
	public typealias ApplyFailure = Failure

	private let action: Action<Input, Output, Failure>
	private var passthroughSubject: PassthroughSubject<Output, Failure>?
	private var currentCancellable: AnyCancellable?

	@Published public private(set) var isExecuting: Bool
	@Published public private(set) var isEnabled: Bool

	public var isExecutingPublisher: AnyPublisher<Bool, Never> {
		self.$isExecuting.eraseToAnyPublisher()
	}

	public var isEnabledPublisher: AnyPublisher<Bool, Never> {
		self.$isEnabled.eraseToAnyPublisher()
	}

	public var values: AnyPublisher<Output, Never> {
		self.action.values
	}

	public var errors: AnyPublisher<Failure, Never> {
		self.action.errors
	}

	private var cancellables = Set<AnyCancellable>([])

	///
	/// Initializes a `CoalescingAction`.
	///
	/// When the `Action` is asked to start the execution with an input value, a unit of
	/// work — represented by a `Publisher` — would be created by invoking
	/// `execute` with the input value.
	///
	/// - parameters:
	///   - execute: A closure that produces a unit of work, as `Publisher`, to be
	///              executed by the `Action`.
	///
	public init<ExecutePublisher: Combine.Publisher>(
		execute: @escaping (Input) -> ExecutePublisher
	) where ExecutePublisher.Output == Output, ExecutePublisher.Failure == Failure {
		self.action = Action(execute: execute)
		self.isEnabled = self.action.isEnabled
		self.isExecuting = self.action.isExecuting
		self.action.isEnabledPublisher.assign(to: \.isEnabled, withoutRetaining: self)
			.store(in: &self.cancellables)
		self.action.isExecutingPublisher.assign(to: \.isExecuting, withoutRetaining: self)
			.store(in: &self.cancellables)
	}

	///
	/// Create a `AnyPublisher` that would attempt to create and start a unit of work of
	/// the `Action`. The `AnyPublisher` would forward only events generated by the unit
	/// of work it created.
	///
	/// - Warning: Only the first call to `apply()` when the action's `isExecuting`'s `value` is `false` will be using its parameters.
	///   Subsequent calls when the action is already executing will ignore the input.
	///
	/// - Parameters:
	///   - input: The initial input to use for the action.
	///
	/// - Returns: A publisher that forwards events generated by its started unit of work. If the action was already executing, it will create a `AnyPublisher`
	///   that will forward the events of the initially created `AnyPublisher`.
	///
	public func apply(_ input: Input) -> AnyPublisher<Output, Failure> {
		let passthroughSubject = PassthroughSubject<Output, Failure>()
		self.currentCancellable = nil
		self.currentCancellable = self.action.apply(input)
			.unwrappingActionError()
			.subscribe(passthroughSubject)
		self.passthroughSubject = passthroughSubject
		return passthroughSubject
			.handleEvents(
				receiveTermination: { [weak self] in
					self?.currentCancellable = nil
				}
			)
			.eraseToAnyPublisher()
	}
}

#endif
